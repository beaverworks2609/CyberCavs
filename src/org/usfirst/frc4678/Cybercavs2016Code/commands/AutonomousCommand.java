// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.commands;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;

public class AutonomousCommand extends Command {

	
	
	public int previousShooterState = 0;
	
	private static final int RAMPARTS = 1;
	private static final int MOAT = 0;

	
	//RAMPARTS auto states
	private static final int MOVE_TO_OUTER_WORKS = 0;
	private static final int TRAVERSE_OUTER_WORKS = 1;
	private static final int MOVE_SLIGHTLY_FORWARD = 2;
	private static final int STRAIGHTEN_OUT = 3;
	private static final int TURN_180 = 4;
	private static final int READY_CAMERA_AND_LIGHTS = 6;
	private static final int AUTO_AIM = 7;
	private static final int SHOOT = 8;
	private static final int STRAIGHTEN = 9;
	private static final int MOVE_TO_NEUTRAL_ZONE = 11;
	private static final int MOVE_TO_OUTER_WORK = 10;
	
//	enum RampartCaseType {TURN_90, TRAVERSE_OUTER_WORKS, MOVE_TO_OUTER_WORKS, STRAIGHTEN_OUT};
//	RampartCaseType rampartCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
//	
//	RampartCaseType moatCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
	int count = 0;
	int autoMode = 0;
	int rampartCase = 0;
	int moatCase = 0;
	int lowBarCase = 0;
	int drawBridgeCase = 0;
	int sallyCase = 0;
	int roughCase = 0;
	int chevalCase = 0;
	int autoDefense = 0;
	int autoPosition = 0;
	double timeIdx = 0;
	boolean isFinished = false;
	double amountToTurn = 0;
	double lastFPGA = 0;
	double fpgaDiff = 0;
	double timeCount = 0;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.robotDrive);
		requires(Robot.manipulatorArm);
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.catapult.setLatchServo(Robot.latchLockPosition()); // Try to prevent bad launches in auto.
		autoDefense = 0;
		autoPosition = 0;
		if (Robot.oi.getAutoSwitch().getRawButton(14)) { //determines which position the switch is in for auto mode
			autoDefense += 1;
		}
		if (Robot.oi.getAutoSwitch().getRawButton(15)) { 
			autoDefense += 2;
		}
		if (Robot.oi.getAutoSwitch().getRawButton(16)) { 
			autoDefense += 4;
		}
		
		if (Robot.oi.getAutoSwitch().getRawButton(13)) { //determines which position switch is in for auto positioning
			autoPosition += 1;
		}
		if (Robot.oi.getAutoSwitch().getRawButton(12)) {
			autoPosition += 2;
		}
		if (Robot.oi.getAutoSwitch().getRawButton(11)) {
			autoPosition += 4;
		}
		
		
		Robot.robotDrive.setIsInAuto(true);
		Robot.robotDrive.resetGyro();
		Robot.robotDrive.resetEncoders();
		//Robot.robotDrive.resetGoToDistanceState();
		Robot.pickupArm.setArmMode("Hold"); 
		if (autoPosition == 2) { // if the auto position is two we will need to turn about 27 degrees right toward the target
			amountToTurn = 27;
		}
		else if (autoPosition == 5) {//in position 5 we need to turn 20 degress left to look at the target
			amountToTurn = -20;
		}
		
		else if (autoPosition == 3) { // in position 3 need just a small 10 degree right
			amountToTurn = 10;
		}
		else { //any other position doesn't require any turning, position 1 is its own thing
			amountToTurn = 0;
		}
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA;
		lastFPGA = Timer.getFPGATimestamp();
		switch(autoDefense) {
//		case MOAT:	
//			moatAuto();
//			break;
//		case RAMPARTS:
//			rampartsAuto(); 
//			break;
//		case 2:
//			if (count > 50) {
//				Robot.catapult.shootBoulder();
//			}
//			else {
//				Robot.pickupArm.setArmMode("ShootMode");
//				Robot.manipulatorArm.setManipulatorMode("ShootMode");
//			}
//			count++;
//			break;
		case 0: // if defense selector is 0 it will run low bar
			low_Bar_Auto();
			break;
			
		case 1: // if defense selector is 1 it will run drawbridge
			drawBridgeAuto();
			break;
		case 2: // if defense selector is 2 it will run sallyport
			sallyPort_Auto();
			break;
		case 3:
			roughTerrain_Auto();
			break;
		case 4:
			switch(chevalCase){
			case 0:
				if (Robot.robotDrive.Cheval()) {
					chevalCase++;
					count = 0;
				}
				break;
			case 1:
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				if (count > 15) {
					chevalCase++;
					Robot.robotDrive.resetGoToDistanceState();
				}
				count++;
				break;		
			case 2:
				Robot.robotDrive.goToDistance(-100, -100, 0.5, 10, 10, 0.4, 0.5);
				if (Robot.robotDrive.getFrontLightSensorValue() < 1200) {
					chevalCase++;
					Robot.robotDrive.resetGoToDistanceState();
					Robot.robotDrive.setLeftMotor(0);
					Robot.robotDrive.setRightMotor(0);
					count = 0;
				}
				break;
			case 3:
				if(Robot.robotDrive.gyroTurn(0)) {
					if (count > 15) {
						chevalCase++;
						count = 0;
					}
					count++;
				}
				break;
			case 4:
				int backup = -75;
				if (autoPosition == 2) {
					backup -= 150;
				}
				if (Robot.robotDrive.goToDistance(backup, backup, 0.5, 10, 10, 0.4, 0.5)) {
					chevalCase++;
					Robot.robotDrive.resetGoToDistanceState();
					Robot.robotDrive.setLeftMotor(0);
					Robot.robotDrive.setRightMotor(0);
				}
				break;
			case 5:
				int addToTurn = 180;
				if (autoPosition == 2) {
					addToTurn = -160;
				}
				if(Robot.robotDrive.gyroTurn(amountToTurn + addToTurn)) {
					chevalCase++;
					Robot.robotDrive.resetGoToDistanceState();
					Robot.robotDrive.setLeftMotor(0);
					Robot.robotDrive.setRightMotor(0);
				}
				break;
			case 6:
				Robot.camera.cameraLightsOn();
				Robot.robotDrive.autoAimInit();
				Robot.manipulatorArm.readyToShoot();
				Robot.pickupArm.setArmMode("ShootMode");
				count = 0;
				chevalCase++;
				break;
			case 7:
				if (count > 10) {
					chevalCase++;
				}
				count++;
				break;
			case 8://auto aims
				if(Robot.robotDrive.autoAim()) {
					chevalCase++;
					Robot.camera.cameraLightsOff();
				}
				else {
					Robot.camera.cameraLightsOn();
				}
				break;
			case 9: // shoots
				Robot.catapult.shootBoulder();
				count ++;
				if (count > 40) { // just so it doens't move immediately after shooting
					chevalCase++;
					count = 0;
				}
				break;
			case 10:
				if (Robot.catapult.getShooterState() != 0) {
					Robot.catapult.shootBoulder();
				}
				if (Robot.robotDrive.gyroTurn(180)) { // straightens out 
					count = 0;
					roughCase++;
				}
				break;
			}
			break;
		}
		
		//System.out.println("Case: " + drawBridgeCase + " AUTO MODE: " + Robot.autoMode());
	}

	private void roughTerrain_Auto() {
		switch(roughCase) {
		case 0:
			Robot.robotDrive.goToDistance(1000, 1000, 0.90, 10, 10, 0.6, 0.6);
			if(Robot.robotDrive.getFrontLightSensorValue() > 1200){
				Robot.robotDrive.resetGoToDistanceState();
				roughCase++;
				count = 0;
			}
			break;
		case 1:	
			if (Robot.robotDrive.isFlat()) {
				Robot.robotDrive.resetGoToDistanceState();
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				if (count > 15) {
					roughCase++;
				}
				count++;
			}
			else {
				Robot.robotDrive.goToDistance(300, 300, 0.90, 10, 10, 0.6, 0.6);
			}
			break;
		case 2:
			if (autoPosition == 2) {
				if (Robot.robotDrive.goToDistance(75, 75, 0.8, 30, 30, 0.4, 0.4)) {
					Robot.robotDrive.resetGoToDistanceState();
					roughCase++;
				}
			}
			else {
				roughCase++;
			}
			
			break;	
		case 3:
			Robot.robotDrive.setLeftMotor(0);
			Robot.robotDrive.setRightMotor(0);
			roughCase++;
			break;
		case 4:
			if(Robot.robotDrive.gyroTurn(amountToTurn)) {
				roughCase++;
				Robot.robotDrive.resetGoToDistanceState();
			}
			break;
		case 5:
			Robot.camera.cameraLightsOn();
			Robot.robotDrive.autoAimInit();
			Robot.manipulatorArm.readyToShoot();
			Robot.pickupArm.setArmMode("ShootMode");
			count = 0;
			roughCase++;
			break;
		case 6:
			if (count > 10) {
				roughCase++;
			}
			count++;
			break;
		case 7://auto aims
			if(Robot.robotDrive.autoAim()) {
				roughCase++;
				Robot.camera.cameraLightsOff();
			}
			else {
				Robot.camera.cameraLightsOn();
			}
			break;
		case 8: // shoots
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 40) { // just so it doens't move immediately after shooting
				roughCase++;
				count = 0;
			}
			break;
		case 9: //prepares to move back to neutral zone
			Robot.catapult.shootBoulder();
			Robot.robotDrive.resetEncoders();
			Robot.robotDrive.resetGoToDistanceState();
			timeCount = 0;
			roughCase++;
			break;
		case 10:
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			if (Robot.robotDrive.gyroTurn(0)) { // straightens out 
				count = 0;
				roughCase++;
			}
			break;
		case 11:
			if (count > 25) {
				roughCase++;
			}
			count++;
			break;
		case 12:
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			if (Robot.robotDrive.goToDistance(-350, -350, 0.75, 20, 20, 0.5, 0.5)){
				roughCase++;
			}
			break;
		case 13:
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			Robot.robotDrive.setLeftMotor(0);
			Robot.robotDrive.setRightMotor(0);
			break;
		}
	}

	private void sallyPort_Auto() {
		switch(sallyCase) { // comments in drawbridge are almost the same as applies here, look at that
		case 0: // drives forward until front of robot is on autoworks
			Robot.robotDrive.goToDistance(1000, 1000, 0.6, 10, 10, 0.4, 0.4);//188
			if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				count = 0;
				sallyCase++;
			}
			break;
		case 1: //drive forward until robot gets stopped by the sally port
			Robot.robotDrive.goToDistance(1000, 1000, 0.4, 0, 0, 0.4, 0.4);//188
			if (Math.abs(Robot.robotDrive.getLeftSpeed()) < 50 && count > 10) {
				
				Robot.robotDrive.setLeftMotor(0); //stops left motor
				Robot.robotDrive.setRightMotor(0); //stops right motor
				Robot.manipulatorArm.setManipulatorElbowMode(5); //set manipulator elbow to position mode
		    	Robot.manipulatorArm.setManipulatorWristMode(5); // sets manipulator wrist to position mode
		    	Robot.manipulatorArm.resetCount();
		    	Robot.manipulatorArm.resetSallyState(); //resets the sally port method state
		    	Robot.robotDrive.resetGoToDistanceState();
				sallyCase++;
			}
			count++;
			break;
		case 2://runs the sally port routine
			if (Robot.manipulatorArm.sallyPort()) { 
				sallyCase++;
			}
			break;
		case 3: // drives forward until the robot is completely on carpet again
			Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);
			if(Robot.robotDrive.isFlat()) {
				Robot.robotDrive.resetGoToDistanceState();
				sallyCase++;
			}
			break;
		case 4: // checks if the position is two it will move forward more, otherwise it will just move on
			if (autoPosition == 2) {
				if (Robot.robotDrive.goToDistance(75, 75, 0.8, 30, 30, 0.4, 0.4)) {
					Robot.robotDrive.resetGoToDistanceState();
					sallyCase++;
				}
			}
			else {
				sallyCase++;
			}
			
			break;	
		case 5: // turns the robot a specified amount based on position
			if(Robot.robotDrive.gyroTurn(amountToTurn)) {
				sallyCase++;
				Robot.robotDrive.resetGoToDistanceState();
			}
			break;
		case 6: // prepares the camera lights and moves the two arms out of the way
			Robot.camera.cameraLightsOn();
			Robot.robotDrive.autoAimInit();
			Robot.manipulatorArm.readyToShoot();
			Robot.pickupArm.setArmMode("ShootMode");
			count = 0;
			sallyCase++;
			break;
		case 7:
			if (count > 10) {
				sallyCase++;
			}
			count++;
			break;
		case 8://auto aims
			if(Robot.robotDrive.autoAim()) {
				sallyCase++;
				Robot.camera.cameraLightsOff();
			}
			else {
				Robot.camera.cameraLightsOn();
			}
			break;
		case 9: // shoots
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 40) { // just so it doens't move immediately after shooting
				sallyCase++;
				count = 0;
			}
			break;
		case 10: //prepares to move back to neutral zone
			Robot.catapult.shootBoulder();
			Robot.robotDrive.resetEncoders();
			timeCount = 0;
			sallyCase++;
			break;
		case 11: // moves back slightly
			
			if (Robot.catapult.getShooterState() != 0) { // if catapult isn't done shooting this continues it
				Robot.catapult.shootBoulder();
			}
			timeCount += fpgaDiff; //keeps acurate track of time
			Robot.robotDrive.DrivePath((timeCount * 75) / 0.5, 5, (timeCount * 75)/0.5, 5);
			if (timeCount > 0.5) {
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				sallyCase++;
			}
			break;
		case 12: //starting here is currently untested it is meant to go back to the neutral zone, turns straight to be ready to move back to neutral zone
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			if (Robot.robotDrive.gyroTurn(0)) { // straightens out 
				sallyCase++;
			}
			break;
		case 13: // moves back until back of robot sees the outer works
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			Robot.robotDrive.goToDistance(-350, -350, 0.8, 10, 10, 0.6, 0.7);
			if (Robot.robotDrive.getBackLightSensorValue() > 900) {
				Robot.robotDrive.resetGoToDistanceState();
				sallyCase++;
			}
			break;
		case 14://moves back until robot is on carpet again (completely in neutral zone again)
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			Robot.robotDrive.goToDistance(-250, -250, 0.8, 10, 10, 0.6, 0.7);
			if (Robot.robotDrive.isFlat()) {
				Robot.robotDrive.resetGoToDistanceState();
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				sallyCase++;
			}
			break;
		case 15: // continues calling shoot if it hasn't finished yet
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			break;
		}
	}

	private void drawBridgeAuto() {
		switch(drawBridgeCase) {
		case 0:
			Robot.robotDrive.goToDistance(1000, 1000, 0.4, 30, 30, 0.4, 0.4);//moves forward until front reaches outer works
			if (Robot.robotDrive.getFrontLightSensorValue() > 1250) {
				Robot.robotDrive.resetGoToDistanceState();
				count = 0;
				drawBridgeCase++;
			}
			break;
		case 1:
			Robot.robotDrive.goToDistance(1000, 1000, 0.45, 20, 20, 0.4, 0.4);//moves forward until wheel speed stops (means bumpers are against drawbridge)
			if (Math.abs(Robot.robotDrive.getLeftSpeed()) < 50 && count > 10) {
				Robot.robotDrive.setLeftMotor(0); // stop motors
				Robot.robotDrive.setRightMotor(0);
				Robot.manipulatorArm.setManipulatorElbowMode(5);
		    	Robot.manipulatorArm.setManipulatorWristMode(5);
		    	Robot.manipulatorArm.resetCount();
		    	Robot.manipulatorArm.resetDrawBridgeState();
		    	Robot.robotDrive.resetGoToDistanceState();
				drawBridgeCase++;
			}
			count++;
			break;
		case 2://pull down draw bridge
			if(Robot.manipulatorArm.drawBridge()) { 
				Robot.robotDrive.resetGoToDistanceState();
				drawBridgeCase++;
			}
			break;
		case 3: // goes forward until outer worked cleared
			Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);
			if(Robot.robotDrive.isFlat()) {
				Robot.robotDrive.resetGoToDistanceState();
				drawBridgeCase++;
			}
			if (Math.abs(Robot.manipulatorArm.getElbowError()) < 2500 && count > 10) {
				Robot.manipulatorArm.setManipulatorWrist(Robot.manipulatorWristRestPosition());
			}
			else {
				Robot.manipulatorArm.setManipulatorWrist(Robot.manipulatorWristRestPosition() - 3500);
			}
		
				count++;
			Robot.manipulatorArm.setManipulatorElbow(Robot.manipulatorElbowRestPosition());
			break;
		case 4: // if in the second position need to move slightly forward for the side goal
			if(autoPosition == 2) {
				if (Robot.robotDrive.goToDistance(75, 75, 0.8, 30, 30, 0.4, 0.4)) {
					drawBridgeCase++;
				}
			}
			else {
				 drawBridgeCase++;
			}
			
			break;	
		case 5: // turns based on auto position
			if(Robot.robotDrive.gyroTurn(amountToTurn)) { 
				drawBridgeCase++;
			}
			break;
		case 6: // ready for auto aiming
			Robot.camera.cameraLightsOn();
			Robot.robotDrive.autoAimInit();
			//Robot.manipulatorArm.setManipulatorMode("ShootMode");
			Robot.manipulatorArm.setManipulatorElbowMode(5);
    		Robot.manipulatorArm.setManipulatorWristMode(5);
    		Robot.manipulatorArm.readyToShoot();
			Robot.pickupArm.setArmMode("ShootMode");
			drawBridgeCase++;
			break;
		case 7: // auto aims
			if(Robot.robotDrive.autoAim()) {
				count = 0;
				drawBridgeCase++;
				Robot.camera.cameraLightsOff();
			}
			else {
				Robot.camera.cameraLightsOn();
			}
			break;
		case 8: //shoots, waits 40 counts after shooting so it doesn't turn too soon
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 40) { // just so it doens't move immediatly after shooting
				drawBridgeCase++;
				count = 0;
			}
			break;
		case 9: //continues calling shoot so it retracts
			Robot.catapult.shootBoulder();
			Robot.robotDrive.resetEncoders();
			timeCount = 0;
			drawBridgeCase++;
			break;
		case 10: //moves back slightly 
			
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			timeCount += fpgaDiff;
			Robot.robotDrive.DrivePath((timeCount * 75) / 0.5, 5, (timeCount * 75)/0.5, 5);
			if (timeCount > 0.5) {
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				drawBridgeCase++;
			}
			break;
		case 11: //turns to straighten out
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			if (Robot.robotDrive.gyroTurn(0)) {
				drawBridgeCase++;
			}
			break;
		case 12: // goes back until the back is on the outer works
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			Robot.robotDrive.goToDistance(-1000, -1000, 0.8, 10, 10, 0.6, 0.7);
			if (Robot.robotDrive.getBackLightSensorValue() > 1250) {
				drawBridgeCase++;
			}
			break;
		case 13: // goes back until the robot is completely in the neutral zone
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			Robot.robotDrive.goToDistance(-1000, -1000, 0.8, 10, 10, 0.6, 0.7);
			if (Robot.robotDrive.checkBackLightSensorIsOnCarpet()) {
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				drawBridgeCase++;
			}
			break;
		case 14: 
			if (Robot.catapult.getShooterState() != 0) {
				Robot.catapult.shootBoulder();
			}
			break;
		}
	}

	private void low_Bar_Auto() {
		switch(lowBarCase) {
		case 0: //moves forward until front sees the outer work
			//Robot.robotDrive.resetGyro();
			Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				lowBarCase++;
			}
			break;
		case 1: //puts arm down to lowbar position, and moves forward until the robot clears the outerworks
			Robot.pickupArm.setArmMode("lowBar");
			Robot.robotDrive.goToDistance(1000, 1000, 0.6, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.isFlat()) {
				Robot.manipulatorArm.setManipulatorElbowMode(5); //sets manipulator elbow mode to position
				Robot.manipulatorArm.setManipulatorWristMode(5); //sets manipulator wrist mode to position
				Robot.manipulatorArm.readyToShoot(); //moves manipulator to ready to shoot position
				Robot.robotDrive.resetGoToDistanceState();
				lowBarCase++;
			}
			break;
		case 2: //moves forward specified distance
			if (Robot.robotDrive.goToDistance(190, 190, 0.8, 30, 30, 0.4, 0.4)) {
				lowBarCase++;
				Robot.robotDrive.resetEncoders();
				timeIdx = 0;
			}
			break;
		case 3: //turns towards the target
//			double speed = 10;
//			double leftPos = timeIdx * speed;
//			double rightPos = timeIdx * -speed;
//			if (timeIdx < 150 / speed) {
//				Robot.robotDrive.DrivePath(leftPos, speed * 5, rightPos, -(speed * 5));
//			} else {
//				Robot.robotDrive.DrivePath(150, 0, -150, 0);
//			}
//			if (timeIdx > 200 / speed) {
//				Robot.robotDrive.setLeftMotor(0);
//				Robot.robotDrive.setRightMotor(0);
//				lowBarCase++;
//			}
//			timeIdx++;
			if(Robot.robotDrive.gyroTurn(45)) {
				lowBarCase++;
			}
			break;
		case 4://prepares camera lights for auto aiming
			Robot.camera.cameraLightsOn();
			Robot.robotDrive.autoAimInit();
			Robot.manipulatorArm.setManipulatorMode("ShootMode");
			lowBarCase++;
			break;
		case 5: // auto aims
			if(Robot.robotDrive.autoAim()) {
				lowBarCase++;
				Robot.camera.cameraLightsOff();
			}
			else {
				Robot.camera.cameraLightsOn();
			}
			break;
		case 6: //shoots
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 40) { // just so it doens't move immediatly after shooting
				lowBarCase++;
				count = 0;
			}
			break;
		case 7: //simply straightens out again, can't move back through the low bar
			Robot.catapult.shootBoulder();
			Robot.robotDrive.gyroTurn(0);
		break;
		}
	}
	

	private void rampartsAuto() { //don't really use these
		switch(rampartCase) {
		case MOVE_TO_OUTER_WORKS:
			if (Robot.robotDrive.goToDistance(140, 140, 0.5, 30, 30, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(1000, 1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
			if (Robot.robotDrive.goToDistance(50, 50, 0.2, 0, 50, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case STRAIGHTEN_OUT:
			
			if (count > 15) { //just provides a slight wait before the robot turns
				Robot.robotDrive.resetGyro();
				rampartCase++;
			}
			if (count > 5) {
				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
			}
			count++;
			break;
		case TURN_180:
			Robot.robotDrive.setLeftTarg(500); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(500);
			Robot.robotDrive.findTarget();
			break;
		case READY_CAMERA_AND_LIGHTS:
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	rampartCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				rampartCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
	    	Robot.camera.cameraLightsOn();
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) { // just so it doens't move immediatly after shooting
				rampartCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
			Robot.robotDrive.setLeftTarg(0); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(0);
			Robot.robotDrive.findTarget();
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.5, 0, 50, 0.3, 0.3);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				rampartCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
		}
	}

	private void moatAuto() { //we don't use this one either
		switch(moatCase)  {
		case MOVE_TO_OUTER_WORKS:
			//Robot.robotDrive.resetGyro();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.8, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.getBackLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				moatCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(-2000, -2000, 1.0, 5, 5, 0.9, 0.9);
			if (Robot.robotDrive.isFlat()) {
				moatCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
//			if (Robot.robotDrive.goToDistance(-100, -100, 0.8, 0, 50, 0.7, 0.7)) {
//				
//			}
			if (count > 10) {
				moatCase++;
				count = 0;
			}
			count++;
			break;
		case STRAIGHTEN_OUT:
			
//			if (count > 15) { //just provides a slight wait before the robot turns
//				Robot.robotDrive.resetGyro();
//				
//			}
//			if (count > 5) {
//				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
//			}
			count = 0;
			Robot.robotDrive.resetEncoders();
			Robot.robotDrive.resetGoToDistanceState();
			moatCase++;
			break;
		case TURN_180:
	    	//Robot.robotDrive.setTarget(690, -690);
	    	 // this will depend on the position we are in, likely change this later
			if (Robot.robotDrive.goToDistance(90.5, -90.5, 0.9, 0, 10, 0.7, 0.3)) {
				moatCase++;
			}
			break;
		case 5:
			if (count > 10) {
				if (Robot.robotDrive.goToDistance(10, 10, 0.9, 0, 50, 0.7, 0.7)) {
					moatCase++;
				}
				
			}
			count++;
			break;
		case READY_CAMERA_AND_LIGHTS:
			count = 0;
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	moatCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				moatCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
			else {
				Robot.camera.cameraLightsOn();
			}
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) {
				//moatCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
//			Robot.robotDrive.setTarget(0, 0);
//	    	//Robot.robotDrive.resetEncoders();
//			Robot.robotDrive.findTarget();
			Robot.catapult.shootBoulder();
			moatCase++;
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				moatCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				moatCase++;
			}
			break;
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
		//System.out.println("previous auto state : " + Robot.catapult.getShooterState());
		//Robot.catapult.setPreviousShooterState(Robot.catapult.getShooterState());
		Robot.catapult.setWinchMotor(0); // stops the winch so it doesn't keep going after auto
		Robot.robotDrive.setIsInAuto(false);
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}
}
