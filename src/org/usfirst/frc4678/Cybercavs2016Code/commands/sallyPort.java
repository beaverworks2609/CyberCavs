// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4678.Cybercavs2016Code.commands;

import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc4678.Cybercavs2016Code.Robot;

/**
 *
 */
public class sallyPort extends Command {
	
	double time = 0;
	double kElbow = 0;
	double kWrist = 0;
	double wristPosition = 0;
	double wristSpeed = 0;
	double elbowPosition = 0;
	double elbowSpeed = 0;
	double wristPositionError = 0;
	double elbowPositionError = 0;
	double wristSpeedSet = 0;
	double elbowSpeedSet = 0;
	boolean lookupDone = false;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public sallyPort() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.manipulatorArm);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.robotDrive);
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	Robot.manipulatorArm.setManipulatorElbowMode(5);
    	Robot.manipulatorArm.setManipulatorWristMode(5);
    	Robot.manipulatorArm.comboindex = 0;
    	Robot.manipulatorArm.speed_mult= 1;
    	time = 0;
    	lookupDone = false;
    	Robot.manipulatorArm.resetCount();
    	Robot.manipulatorArm.resetSallyState();
    	Robot.robotDrive.resetEncoders();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
//    	if(Robot.manipulatorArm.lookup(time)) {
//    		kElbow = 0.4;
//    		kWrist = 0.4;
//    		wristPosition = (Robot.manipulatorArm.wristPos);
//    		wristSpeed = (Robot.manipulatorArm.wristSpeed);
//    		elbowPosition = (Robot.manipulatorArm.elbowPos);
//    		elbowSpeed = (Robot.manipulatorArm.elbowSpeed);
//    		
//    		wristPositionError = wristPosition - Robot.manipulatorArm.getManipulatorWristPosition(); 
//    		elbowPositionError = elbowPosition - Robot.manipulatorArm.getManipulatorElbowPosition();
////    		System.out.println(time + ", " + wristPosition + ", " + wristSpeed + ", " + wristPositionError + ", " + elbowPosition + ", " + elbowSpeed + ", " + elbowPositionError);
////    		System.out.println(elbowSpeed + (kElbow * elbowPositionError) + ", " + wristSpeed + (kWrist * wristPositionError));
//    		// Negative Speeds do reduce position readings.  Position readings are only updated at about every 5 or 6 readings (about 10Hz)
//    		// Elbow speed calculations appear correct but are likely rather high
//    		// Need a reasonable start position.
//    		Robot.manipulatorArm.setManipulatorElbow(elbowSpeed + (kElbow * elbowPositionError));
//    		Robot.manipulatorArm.setManipulatorWrist(wristSpeed + (kWrist * wristPositionError));
//    		wristSpeedSet = wristSpeed + (kWrist * wristPositionError);
//    		elbowSpeedSet = elbowSpeed + (kElbow * elbowPositionError);
//    		System.out.println("w" + ", " + wristPosition + ", " + Robot.manipulatorArm.getManipulatorWristPosition() + ", " + wristPositionError + ", " + wristSpeed + ", " + wristSpeedSet + ", " + Robot.manipulatorArm.getWristSpeed());
//    		System.out.println("e" + ", " + elbowPosition + ", " + Robot.manipulatorArm.getManipulatorElbowPosition() + ", " + elbowPositionError + ", " + elbowSpeed + ", " + elbowSpeedSet + ", " + Robot.manipulatorArm.getElbowSpeed());
//    		
//    		time = time + 0.02;
//    	}
//    	else {
//    		lookupDone = true;
//    	}
    	Robot.manipulatorArm.sallyPort();
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    	Robot.manipulatorArm.resetCount();
    	Robot.manipulatorArm.setManipulatorMode("ExitSallyPort");
    	
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	end();
    }
}
