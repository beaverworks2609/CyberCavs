// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.subsystems;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;
import org.usfirst.frc4678.Cybercavs2016Code.RobotMap;
import org.usfirst.frc4678.Cybercavs2016Code.commands.SetManipulatorArm;
import org.usfirst.frc4678.Cybercavs2016Code.commands.SetPickupArm;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class PickupArm extends Subsystem {
	public int pickupState = 0;
	public int spitState = 0;
	public int lowBarState = 0;
	PowerDistributionPanel pdp = new PowerDistributionPanel();
	int count = 0;
	int cnt = 0;
	int cnt1 = 0;
	int wristStartPosition = 0;
	int elbowStartPosition = 0;
	int timeCount = 0;
	boolean isPickupPosition = false;
	boolean wristInPosition = false;
	boolean elbowInLowPos = false;
	double elbowPosition = 0;
	double elbowSpeed = 0;
	double wristPosition = 0;
	double wristSpeed = 0;
	double wristPositionError = 0;
	double elbowPositionError = 0;
	double kWrist = 0;
	double kElbow = 0;
	double[][] positionSpeed = new double[][]{
		{23959, 656.0, 41016, -3.0},
		{24648, 609.0, 41016, -16.0},
		{24648, 565.0, 40822, -48.0},
		{24648, 532.0, 40822, -108.0},
		{24648, 505.0, 40822, -195.0},
		{24648, 473.0, 40822, -301.0},
		{24648, 421.0, 40822, -413.0},
		{24991, 343.0, 40822, -522.0},
		{24991, 250.0, 39943, -621.0},
		{24991, 159.0, 39943, -708.0},
		{24991, 85.0, 39943, -782.0},
		{24991, 27.0, 39943, -848.0},
		{24991, -14.0, 39943, -905.0},
		{24903, -58.0, 39943, -951.0},
		{24903, -111.0, 38746, -983.0},
		{24903, -180.0, 38746, -1000.0},
		{24903, -180.0, 38746, -997.0},
		{24903, -258.0, 38746, -978.0},
		{24903, -339.0, 38746, -978.0},
		{24325, -415.0, 38746, -947.0},
		{24325, -482.0, 37714, -914.0},
		{24325, -536.0, 37714, -882.0},
		{24325, -584.0, 37714, -853.0},
		{24325, -627.0, 37714, -822.0},
		{24325, -670.0, 37714, -789.0},
		{23426, -714.0, 37714, -752.0},
		{23426, -761.0, 36919, -716.0},
		{23426, -808.0, 36919, -679.0},
		{23426, -856.0, 36919, -645.0},
		{23426, -904.0, 36919, -612.0},
		{23426, -954.0, 36919, -578.0},
		{22195, -1004.0, 36919, -539.0},
		{22195, -1056.0, 36404, -493.0},
		{22195, -1108.0, 36404, -439.0},
		{22195, -1160.0, 36404, -381.0},
		{22195, -1211.0, 36404, -324.0},
		{22195, -1258.0, 36404, -278.0},
		{20627, -1258.0, 36404, -242.0},
		{20627, -1300.0, 36175, -215.0},
		{20627, -1334.0, 36175, -215.0},
		{20627, -1357.0, 36175, -190.0},
		{20627, -1367.0, 36175, -163.0},
		{20627, -1362.0, 36175, -131.0},
		{19054, -1340.0, 36175, -97.0},
		{19054, -1302.0, 36143, -64.0},
		{19054, -1247.0, 36143, -37.0},
		{19054, -1172.0, 36143, -17.0},
		{19054, -1074.0, 36143, -5.0},
		{19054, -950.0, 36143, 0.0},
		{18183, -810.0, 36143, 0.0},
		{18183, -663.0, 36143, 0.0},
		{18183, -513.0, 36143, 2.0},
		{18183, -368.0, 36143, 11.0},
		{18183, -231.0, 36143, 39.0},
		{18183, -115.0, 36143, 113.0},
		{18163, -26.0, 36143, 250.0},
		{18163, 25.0, 36929, 440.0},
		{18163, 50.0, 36929, 653.0},
		{18163, 50.0, 36929, 851.0},
		{18163, 64.0, 36929, 999.0},
		{18163, 87.0, 36929, 999.0},
		{18372, 125.0, 36929, 1087.0},
		{18372, 177.0, 38384, 1134.0},
		{18372, 236.0, 38384, 1174.0},
		{18372, 297.0, 38384, 1220.0},
		{18372, 362.0, 38384, 1269.0},
		{18372, 434.0, 38384, 1304.0},
		{19057, 512.0, 38384, 1317.0},
		{19057, 589.0, 39885, 1301.0},
		{19057, 657.0, 39885, 1267.0},
		{19057, 709.0, 39885, 1224.0},
		{19057, 747.0, 39885, 1178.0},
		{19057, 774.0, 39885, 1128.0},
		{20033, 800.0, 39885, 1070.0},
		{20033, 831.0, 40952, 997.0},
		{20033, 872.0, 40952, 905.0},
		{20033, 926.0, 40952, 793.0},
		{20033, 984.0, 40952, 663.0},
		{20033, 1037.0, 40952, 525.0},
		{21322, 1037.0, 40952, 385.0},
		{21322, 1074.0, 41151, 258.0},
		{21322, 1090.0, 41151, 154.0},
		{21322, 1084.0, 41151, 154.0},
		{21322, 1061.0, 41151, 80.0},
		{21322, 1031.0, 41151, 33.0},
		{22485, 999.0, 41151, 9.0}
	};
	String armMode;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon pickupElbowMotor = RobotMap.pickupArmpickupElbowMotor;
    private final CANTalon pickupWristMotor = RobotMap.pickupArmpickupWristMotor;
    private final CANTalon pickupWheels = RobotMap.pickupArmpickupWheels;
    private final DigitalInput ballSensor = RobotMap.pickupArmballSensor;
    private final DigitalInput backBallSensor = RobotMap.pickupArmbackBallSensor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
	int wristHoldPosition = Robot.holdWristPosition(); //spitout for wrist and elbow are now relative, if this issue later change back
	int wristPickupPosition = Robot.holdWristPosition() + 16413;
	int wristSpitOutPosition = Robot.holdWristPosition() + 7864;
	int wristLowBarPosition = Robot.holdWristPosition() + 19000;
	int elbowHoldPosition = Robot.holdElbowPosition();
	int elbowPickupPosition = Robot.holdElbowPosition() + 36712; //was 34712
	int elbowSpitOutPosition = Robot.holdElbowPosition() + 10270;
	int elbowLowBarPosition = Robot.holdElbowPosition() + 43646;
	int elbowShootPosition = Robot.holdElbowPosition() + 27501;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new SetPickupArm());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	//////////////////////////////////////
	////////// Access functions//////////
	/////////////////////////////////////

	public int getElbowPosition() {	return pickupElbowMotor.getEncPosition();}

	public int getWristPosition() {return pickupWristMotor.getEncPosition();}

	public int getPickupWheelsPosition() {	return pickupWheels.getEncPosition();}

	public double getCurrent(int channel) {	return pdp.getCurrent(channel);}
	
	public double getWristError() {return pickupWristMotor.getError();}
	
	public String getArmMode() {return armMode;}

	public int getWristAngular() {return pickupWristMotor.getPulseWidthPosition();}
	
	public int getElbowAngular() {return pickupElbowMotor.getPulseWidthPosition();}
	
	public boolean getBackSensor() {return backBallSensor.get();}
	
	public double getPickupWheelsSpeed() {return pickupWheels.getSpeed();}
	
	public double getElbowError() {return pickupElbowMotor.getError();}
	
	/////////////////////////////////////
	////////// Setter functions//////////
	/////////////////////////////////////
	
	public void setPickupWheelsMode(int mode) {
		if (mode == 0) {
			pickupWheels.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			pickupWheels.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			pickupWheels.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			pickupWheels.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			pickupWheels.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			pickupWheels.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			pickupWheels.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			pickupWheels.changeControlMode(TalonControlMode.Voltage);
		}
	}

	public void setElbowMode(int mode) {
		if (mode == 0) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			pickupElbowMotor.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			pickupElbowMotor.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			pickupElbowMotor.changeControlMode(TalonControlMode.Voltage);
		}
	}

	public void setWristMode(int mode) {
		if (mode == 0) {
			pickupWristMotor.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			pickupWristMotor.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			pickupWristMotor.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			pickupWristMotor.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			pickupWristMotor.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			pickupWristMotor.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			pickupWristMotor.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			pickupWristMotor.changeControlMode(TalonControlMode.Voltage);
		}
	}

	public void setPickupWheels(double voltage) {
		pickupWheels.set(voltage);
	}
	public void resetPickupState() {
		pickupState = 0;
	}
	public void resetSpitState() {
		spitState = 0;
	}
	public void resetArmEncValues() {
		pickupElbowMotor.setEncPosition(0);
		pickupWristMotor.setEncPosition(0);
	}
	public void setArmMode(String Mode) {
		armMode = Mode;
	}
	public void resetElbowInLow() {
		elbowInLowPos = false;
	}
	
	////////////////////////////////////////////////////
	////////// Functions to set Arms positions//////////
	////////////////////////////////////////////////////
	
	public void setElbowPosition(int position) { //function to move the elbow with pid movement
		if ((pickupElbowMotor.getPosition() < 11000) && (armMode == "Hold")) {
			pickupElbowMotor.configPeakOutputVoltage(+3f, -3f); // lowers power when arm is close to hold position //was 3
		}
		else {
			pickupElbowMotor.configPeakOutputVoltage(+9f, -9f); //max and min power //was 9
		}
		pickupElbowMotor.setPID(0.3, 0.0, 0.0); //PID values
		pickupElbowMotor.setAllowableClosedLoopErr(20);
		pickupElbowMotor.set(position); // allowable error in the PID position movement
	}

	public void setWristPosition(int position) {
		if ((pickupElbowMotor.getPosition() < 11000) && (armMode == "Hold")) {
			pickupWristMotor.configPeakOutputVoltage(+4f, -4f); // lowers power when arm close to hold //was 4
		} else {
			pickupWristMotor.configPeakOutputVoltage(6f, -6f);  //max and min power //was 6
		}
		
		pickupWristMotor.setPID(0.7, 0, 0); // PID values
		pickupWristMotor.setAllowableClosedLoopErr(20); // allowable error in the PID position movement
		pickupWristMotor.set(position);
	}
	
	
	//////////////////////////////////////////////
	//////////Arm Positioning functions//////////
	////////////////////////////////////////////
	public void pickup() {
		switch(pickupState) {
		case 0: //moves Arm to higher position and waits for wrist to be in position
//			setWristPosition(wristPickupPosition);
//			if (pickupElbowMotor.getEncPosition() > 10000) {  //
//				setWristPosition(wristPickupPosition);
//				if (pickupWristMotor.getEncPosition() > 5229) { //detects if wrist is in position so that the elbow may continue moving
//					setElbowPosition(elbowPickupPosition);
//					setPickupWheels(Robot.pickupWheelsPower());
//				}
//			}
//			else {
//				setElbowPosition(elbowPickupPosition - 25000);//moves arm to specific location until the wrist is in position so we don't go over 15 in
//			}
			setElbowPosition(elbowPickupPosition);
			if (pickupElbowMotor.getError() < 10000) {
				pickupWristMotor.changeControlMode(TalonControlMode.Position);
				setWristPosition(wristPickupPosition);
				if (Robot.oi.getOperatorGamepad().getRawButton(9)) {
					setPickupWheels(-Robot.pickupWheelsPower() / 1.3);
				} else {
					setPickupWheels(Robot.pickupWheelsPower());
				}
				if (!backBallSensor.get()) { //starts incrementing count once the back sensor sees the ball
					count++;			
				}
				else {
					count = 0;
				}
				if (count > 15 || Robot.oi.driverGamepad.getRawButton(12)) { // after 15 counts (~1/4 of a second) it assumes the ball is centered and proceeds to pick up the ball
					pickupState++;
					count = 0;
				}
				if (!ballSensor.get()) {
					pickupState=2;
				}
			}
			else {
				pickupWristMotor.changeControlMode(TalonControlMode.Voltage);
				pickupWristMotor.set(0);
			}
			

		break;
		case 1://moves the wrist out and the elbow down to lift the ball over the bumper
			//System.out.println("IN CASE 1!!!!");
			if (Robot.oi.getOperatorGamepad().getRawButton(9)) {
				setPickupWheels(-Robot.pickupWheelsPower()/1.3);
			} else {
				setPickupWheels(Robot.pickupWheelsPower());
			}
			setWristPosition(wristPickupPosition + 1000); 
			setElbowPosition(elbowPickupPosition + 2000);
			if (!ballSensor.get()) {
				pickupState++;
			}
		break;
		case 2: //Once elbow is high enough it will wait for the ball the settle in the catapult
			setElbowPosition(elbowHoldPosition + 5000); //moves arm to this position to allow the ball to have time to settle in the robot
			count++;
			if (count > 25) {
				setPickupWheels(0);
				setArmMode("Hold");
				count = 0;
			}
			if (count > 10) {
				setPickupWheels(0);
			}
		break;
		}
	}
	public void holdPosition() {
		setElbowPosition(elbowHoldPosition);
		if (Math.abs(pickupElbowMotor.getError()) < 1000) { //moves the elbow first once within an error then moves wrist
			pickupWristMotor.changeControlMode(TalonControlMode.Position);
			setWristPosition(wristHoldPosition);
		}
		else { //stops the wrist if elbow not inposition yet
			pickupWristMotor.changeControlMode(TalonControlMode.Voltage);
			pickupWristMotor.set(0);
		}
		setPickupWheels(0);
		//System.out.println("Elbow Error :" + pickupElbowMotor.getError());
	}
	public void spitOut() {
		switch(spitState) {
//		case 0:	//reverses wheels, moves elbow
//			setPickupWheels(-Robot.pickupWheelsPower());
//			setElbowPosition(elbowSpitOutPosition);
//			if (Math.abs(pickupElbowMotor.getError()) < 700) { //this is in the make sure the arm moves before the wrist so the wrist doesn't crash against the robot
//				spitState++;
//			}
//		break;
//		case 1: // once elbow is moved begin the move wrist
//			setWristPosition(wristSpitOutPosition);
//			if (pickupWristMotor.getEncPosition() < -34500) { // if wrist is in desired position is will continue
//				spitState++;
//			}
//		break;
//		case 2: //move elbow up to give the ball more push out the robot
//			setElbowPosition(elbowSpitOutPosition + 8500); 
		
		case 0: //reversed the pickup wheels and sets the wrist position
			setPickupWheels(-Robot.pickupWheelsPower());
			setWristPosition(Robot.holdWristPosition());
			if (count > 2) { //give very small time for the ball to get moving out of the robot
				count = 0;
				spitState++;
			}
			count++;
			break;
		case 1: //moves the elbow and the wrist out to give the ball a push
			setElbowPosition(Robot.holdElbowPosition() + 11000);
			setWristPosition(Robot.holdWristPosition() + 8000);
			break;
		}
	}
	
	public void lowBarPosition() {
//		switch(lowBarState) {
//		
//		case 0:
//			pickup();
//			if (pickupElbowMotor.getError() < 500)  {
//				lowBarState++;
//			}
//			break;
//		case 1:
//			setElbowPosition(Robot.lowBarElbowPosition());
//			setPickupWheels(0);
//			break;
//		}
		setElbowPosition(elbowLowBarPosition);
		if (pickupElbowMotor.getError() < 5000 && count > 10 || elbowInLowPos) { // moves the elbow first, once its in position wrist can be moved
			count = 0;
			pickupWristMotor.changeControlMode(TalonControlMode.Position);
			pickupWristMotor.set(wristLowBarPosition);
			elbowInLowPos = true;
			setPickupWheels(0);
		}
		else {
			setPickupWheels(-6);
			pickupWristMotor.changeControlMode(TalonControlMode.Voltage);
			pickupWristMotor.set(0);
		}
		count++;
	}
	public void readyToShoot() {
		setPickupWheels(0);
		pickupWristMotor.changeControlMode(TalonControlMode.Voltage);
		pickupWristMotor.set(0);
		setElbowPosition(elbowShootPosition);
	}
	
	///////////////////////////////////
	//////////Misc Functions//////////
	/////////////////////////////////
	
	public void stopArmMotors() {
		pickupElbowMotor.disable();
		pickupWristMotor.disable();
		pickupWheels.disable();
	}
	public void stopIntakeWheels() {
		pickupWheels.disable();
	}
	public void CalibratePickup() { //this runs in robotinit
		wristStartPosition = (pickupWristMotor.getPulseWidthPosition() % 4096); //there are 4096 encoder clicks per revolution
		elbowStartPosition = (pickupElbowMotor.getPulseWidthPosition() % 4096);// doing this gets them to start in the expected position
		if (wristStartPosition < 0) {
			wristStartPosition = wristStartPosition + 4096;
		}
		if (elbowStartPosition < 0) {
			elbowStartPosition = elbowStartPosition + 4096;
		}
//		if (wristStartPosition < 1500) {
//			wristStartPosition = wristStartPosition + 4096;
//		}
		pickupWristMotor.setPulseWidthPosition(wristStartPosition);
		pickupElbowMotor.setPulseWidthPosition(elbowStartPosition);
		pickupWristMotor.setEncPosition(wristStartPosition);
		pickupElbowMotor.setEncPosition(elbowStartPosition);
	}
	public void pickupOsc() { //test code to make the pickup arm follow a path
		kElbow = 0.6;
		kWrist = 0.6;
		wristPosition = (positionSpeed[cnt][0]);
		wristSpeed = (positionSpeed[cnt][1]);
		elbowPosition = (positionSpeed[cnt][2]);
		elbowSpeed = (positionSpeed[cnt][3]);
		cnt++;
		if (cnt >= 85) {
			cnt = 0;
		}
		wristPositionError = wristPosition - pickupWristMotor.getEncPosition(); 
		elbowPositionError = elbowPosition - pickupElbowMotor.getEncPosition();
		//System.out.println(wristPosition + ", " + wristSpeed + ", " + elbowPosition + ", " + elbowSpeed + ", ");
		pickupElbowMotor.configPeakOutputVoltage(+5f, -5f); //max and min power
		pickupElbowMotor.setPID(0.2, 0, 0); //PID values
		pickupElbowMotor.setAllowableClosedLoopErr(100);
		pickupElbowMotor.set(elbowSpeed + (kElbow * elbowPositionError)); // allowable error in the PID position movement
		
		pickupWristMotor.configPeakOutputVoltage(+5f, -5f); //max and min power
		pickupWristMotor.setPID(0.15, 0, 0); // PID values
		pickupWristMotor.setAllowableClosedLoopErr(100); // allowable error in the PID position movement
		pickupWristMotor.set(wristSpeed + (kWrist * wristPositionError));
	
		
		//System.out.println(wristPositionError + ", " + wristPosition + ", " + wristSpeed + ", " + elbowPositionError + ", " + elbowPosition +", " + elbowSpeed);
	}
	
	int calPstate = 0;
	public boolean calibratePickup() { // Before this routine is executed, need to make sure the catapult has been winched in.
		boolean retval = false;
		switch(calPstate) {
			case 0: // Start with Elbow moving in and keep wrist power off
				setElbowMode(4);
				pickupElbowMotor.set(0.3);
				setWristMode(4);
				pickupWristMotor.set(0);
				if (count > 10 && pickupElbowMotor.getSpeed() < 10) {
					calPstate++;
					count = 0;
				}
				count++;
				break;
			case 1: // When Elbow speed gets really slow (or 0), assume we are fully retracted
				// Can set incremental encoders to equal the angle encoder reading. And initialize retract of wrist
				// Set elbow to maintain position so motion of wrist does not just move the elbow.
				break;
			case 2: // When Wrist speed gets really slow (or 0), assume we are fully retracted.  There probably won't be
				// a ball in the robot.  See if we can detect the difference based on the angular reading
				break;
			case 3: // We are done.  Return true
				retval = true;
				calPstate = 0; // Set state back to 0 in case we need to do this again.
				break;
		}
	return retval; // Will return true when we get to the last case			
	}
}
