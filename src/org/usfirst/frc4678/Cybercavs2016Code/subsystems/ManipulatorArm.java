// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4678.Cybercavs2016Code.subsystems;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;
import org.usfirst.frc4678.Cybercavs2016Code.RobotMap;
import org.usfirst.frc4678.Cybercavs2016Code.commands.*;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.StatusFrameRate;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class ManipulatorArm extends Subsystem {
	
	int SPEED_FACTOR = 25;
	
	enum joints {TIME, WRIST, ELBOW, LEFT, RIGHT}
	
	static public double wristPos = 0;
	static public double elbowPos = 0;
	static public double leftPos = 0;
	static public double rightPos = 0;
	static public double wristSpeed = 0;
	static public double elbowSpeed = 0;
	static public double leftSpeed = 0;
	static public double rightSpeed = 0;
	
	String manipulatorMode;
	int wristStartPosition = 0;
	int elbowStartPosition = 0;
	int count = 0;
	int sallyState = 0;
	int drawBridgeState = 0;
	int portcullisState = 0;
	int exitSallyState = 0;
	double currentWristPosition = 0;
	double previousWristPosition = 0;
	double wristPosition = 0;
	double elbowPosition = 0;
	double leftEncoder = 0;
	double rightEncoder = 0;
	double kWrist = 0;
	double kElbow = 0;
	double newElbowPosition = 0;
	double timeCount = 0;
	double totalTime = 0;
	double speed = 0;
	double encoderPosition = 0;
	double newWristPosition = 0;
	double fpgaDiff = 0;
	double lastFPGA = 0;
	public static int comboindex = 0;
//	public static double time = 0;
	public static double speed_mult = 0;
	boolean restWrist = false;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon manipulatorElbow = RobotMap.manipulatorArmmanipulatorElbow;
    private final CANTalon manipulatorWrist = RobotMap.manipulatorArmmanipulatorWrist;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    int elbowShootPosition = Robot.manipulatorElbowRestPosition() + 61766;
    int elbowPortcullisPosition = Robot.manipulatorElbowRestPosition() + 59846;
    int wristShootPosition = Robot.manipulatorWristRestPosition() - 9450;
    int wristPortcullisPosition = Robot.manipulatorWristRestPosition() - 8887;
    int wristRestPosition = Robot.manipulatorWristRestPosition();
    int wristStraightUpPosition = Robot.manipulatorWristRestPosition() - 35799;
    int wristSallyReady = Robot.manipulatorWristRestPosition() - 15586;
    int wristSallyPull = Robot.manipulatorWristRestPosition() - 13586;
    int drawBridgeWristReady = Robot.manipulatorWristRestPosition() - 29834;
    int wristSecondPosition = Robot.manipulatorWristRestPosition() - 10068;
    int wristThirdPosition = Robot.manipulatorWristRestPosition() - 13098;
    int wristFourthPosition = Robot.manipulatorWristRestPosition() - 11753;
    int wristFifthPosition = Robot.manipulatorWristRestPosition() -19393
;

    int wristPortcullisReady = Robot.manipulatorWristRestPosition() -9658;
    int wristPortcullisSecond = Robot.manipulatorWristRestPosition() -12101;
    int wristPortcullisThird = Robot.manipulatorWristRestPosition() -20880;
    int wristPortcullisFourth = Robot.manipulatorWristRestPosition() -6762;
    int encoderPortcullisFirst = 260;
    int encoderPortcullisSecond = -365;
    int encoderPortcullisThird = -1265;

    int elbowAfterShootPosition = Robot.manipulatorElbowRestPosition() + 23337;
    int elbowStraightUpPosition = Robot.manipulatorElbowRestPosition() + 47493;
    int elbowSallyReady = Robot.manipulatorElbowRestPosition() + 42196;
    int drawBridgeElbowReady = Robot.manipulatorElbowRestPosition() + 47500;
    int elbowSecondPosition = Robot.manipulatorElbowRestPosition() + 20000; // was 15880
    int elbowThirdPosition = Robot.manipulatorElbowRestPosition() + 59688; // Push down
    int elbowFourthPosition = Robot.manipulatorElbowRestPosition() + 72887; // Push down most of the way
    int elbowFifthPosition = Robot.manipulatorElbowRestPosition() + 74846; // Push down drive forward a bit.
    int elbowSixthPosition = Robot.manipulatorElbowRestPosition() + 50000;
    
    int elbowPortcullisReady = Robot.manipulatorElbowRestPosition() + 70553;
    int elbowPortcullisSecond = Robot.manipulatorElbowRestPosition() + 66697;
    int elbowPortcullisThird = Robot.manipulatorElbowRestPosition() + 48123;
    int elbowPortcullisFourth = Robot.manipulatorElbowRestPosition() + 5786;
    
    int encoderSecondPosition = 338;
    int encoderThirdPosition = 785;
    int encoderFourthPosition = 785;
    int encoderFifthPosition = 273;
    
    int encoderSallyMax = 900;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new SetManipulatorArm());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
   
	//////////////////////////////////////
	//////////Setter Functions//////////
	/////////////////////////////////////
    
    public void setManipulatorWrist(double position) {//function to move wrist with PID movement
    	manipulatorWrist.configPeakOutputVoltage(+12f, -12f); //max and min power
    	manipulatorWrist.setPID(0.27, 0, 0); //PID values
    	manipulatorWrist.setAllowableClosedLoopErr(20);
    	manipulatorWrist.set(position); // allowable error in the PID position movement
    }
    public void setManipulatorElbow(double position) { //function to move elbow with PID movement
    	manipulatorElbow.configPeakOutputVoltage(+12f, -12f); //max and min power
    	manipulatorElbow.setPID(0.27, 0, 0); //PID values
    	manipulatorElbow.setAllowableClosedLoopErr(20);
    	manipulatorElbow.set(position); // allowable error in the PID position movement
    }
    public void resetSallyState() {
    	sallyState = 0;
    }
    public void resetDrawBridgeState() {
    	drawBridgeState = 0;
    }
    public void resetPortcullisState() {
    	portcullisState = 0;
    }

    public void setManipulatorElbowMode(int mode) {
    	manipulatorElbow.setStatusFrameRateMs(StatusFrameRate.QuadEncoder, 10);
	
	// StatusFrameRateGeneral = 0, StatusFrameRateFeedback = 1, StatusFrameRateQuadEncoder = 2, StatusFrameRateAnalogTempVbat = 3, 
	//  StatusFrameRatePulseWidthMeas = 4 
		if (mode == 0) {
			manipulatorElbow.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			manipulatorElbow.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			manipulatorElbow.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			manipulatorElbow.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			manipulatorElbow.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			manipulatorElbow.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			manipulatorElbow.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			manipulatorElbow.changeControlMode(TalonControlMode.Voltage);
		}
	}
	public void setManipulatorWristMode(int mode) {
    	manipulatorWrist.setStatusFrameRateMs(StatusFrameRate.QuadEncoder, 10);
		if (mode == 0) {
			manipulatorWrist.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			manipulatorWrist.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			manipulatorWrist.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			manipulatorWrist.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			manipulatorWrist.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			manipulatorWrist.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			manipulatorWrist.changeControlMode(TalonControlMode.Voltage);
		}
	}
	public void setManipulatorMode(String mode) {
		manipulatorMode = mode;
	}
	
	//////////////////////////////////////
	//////////Accessor Functions//////////
	/////////////////////////////////////
	
	public int getManipulatorWristPosition() {return manipulatorWrist.getEncPosition();}
	
	public int getManipulatorElbowPosition() {return manipulatorElbow.getEncPosition();}
	
	public int getManipulatorWristAngular() {return manipulatorWrist.getPulseWidthPosition();}
	
	public int getManipulatorElbowAngular() {return manipulatorElbow.getPulseWidthPosition();}
	
	public String getManipulatorMode() {return manipulatorMode;}
	
	public double getWristSpeed() {return manipulatorWrist.getSpeed();}
	
	public double getElbowSpeed() {return manipulatorElbow.getSpeed();}
	
	public double getElbowError() {return manipulatorElbow.getError();}
	
	//////////////////////////////////////
	//////////Movement Functions//////////
	/////////////////////////////////////
	
	
	public void restMode() {
		if (Math.abs(manipulatorElbow.getError()) < 1000 && count > 10) { //moves elbow first
			setManipulatorWrist(Robot.manipulatorWristRestPosition());
		}
		else {
			setManipulatorWrist(Robot.manipulatorWristRestPosition() - 5000);
		}
	
			count++;
		setManipulatorElbow(Robot.manipulatorElbowRestPosition());
	}
	public void readyToShoot() { //simply moves both parts at same time, no need to move one first
		setManipulatorWrist(wristShootPosition);
		setManipulatorElbow(elbowShootPosition);
	}
	public void straightUp() { //simply moves both parts at same time, no need to move one first
		setManipulatorWrist(wristStraightUpPosition);
		setManipulatorElbow(elbowStraightUpPosition);
	}
	
	public void CalibrateManipulator() { //calibrates manipulator at the beginning of every match
		wristStartPosition = (manipulatorWrist.getPulseWidthPosition() % 4096);//4096 encoder clicks every rotation
		elbowStartPosition = (manipulatorElbow.getPulseWidthPosition() % 4096);
		if (wristStartPosition < 0) {
			wristStartPosition = wristStartPosition + 4096;
		}
		if (elbowStartPosition < 0) {
			elbowStartPosition = elbowStartPosition + 4096;
		}
		manipulatorWrist.setPulseWidthPosition(wristStartPosition); //sets the angular and the encoder position to be the same
		manipulatorElbow.setPulseWidthPosition(elbowStartPosition);
		manipulatorWrist.setEncPosition(wristStartPosition);
		manipulatorElbow.setEncPosition(elbowStartPosition);
	}
	public void resetCount() {
		count = 0;
	}
//	public void portcullis1() {
//		switch(portcullisState) {
//		
//		case 0:
//			setManipulatorElbow(elbowPortcullisPosition);
//			setManipulatorWrist(wristPortcullisPosition);
//			if(Math.abs(manipulatorElbow.getError()) < 100 && count > 10) {
//				portcullisState++;
//				manipulatorWrist.changeControlMode(TalonControlMode.Voltage);
//				manipulatorElbow.changeControlMode(TalonControlMode.Voltage);
//				manipulatorWrist.set(0);
//				manipulatorElbow.set(0);
//				count = 0;
//			}
//			count++;
//		break;
//		case 1:
//			if(count > 10) {
//				if (Math.abs(wristPortcullisPosition - currentWristPosition) > 300) {
//					Robot.robotDrive.resetEncoders();
//					count = 0;
//					portcullisState++;
//				}
//				previousWristPosition = currentWristPosition;
//			}
//			count++;
//			currentWristPosition = manipulatorWrist.getPosition();
//		break;
//		case 2:
//			wristPosition = manipulatorWrist.getPosition();
//			elbowPosition = manipulatorElbow.getPosition();
//			leftEncoder = Robot.robotDrive.getLeftEncoder();
//			rightEncoder = Robot.robotDrive.getRightEncoder();
//			System.out.println(wristPosition + ", " + elbowPosition + ", " + leftEncoder + ", " + rightEncoder);
//		}
//	}

	public static double interp(double time, double start, double end, double from, double to) { // Do the interpolation calculation
		return((to - from)*((time - start) / (end - start)) + from);
    }
	

	public void afterShoot() { //moves manipulator in a little bit after shooting so its not sticking out
		setManipulatorElbow(elbowAfterShootPosition);
		if (Math.abs(manipulatorElbow.getError()) < 100 && count > 10) {
			setManipulatorWrist(wristRestPosition - 3000);
			count = 0;
		}
		count++;
		//System.out.println("ELBOW ERROR: " + manipulatorElbow.getError());
	}
	public boolean sallyPort() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA; //acurate time tracker
		lastFPGA = Timer.getFPGATimestamp();
		switch(sallyState) {
		case 0: //sets wrist ready for sally, wrist moves first so it doesn't scrap against the door
			setManipulatorWrist(wristSallyReady);
			if (manipulatorWrist.getError() < 250 && count > 10) {//ensures wrist moves first
				setManipulatorElbow(elbowSallyReady);
				sallyState++;
				count = 0;
			}
			count++;
		break;
		case 1: //waits until the elbow is in the right position, then moves to next state
			if (manipulatorElbow.getError() < 250 && count > 10) {
				sallyState++;
				totalTime = 1.0;
				timeCount = 0;
				Robot.robotDrive.resetGoToDistanceState();
				setManipulatorWrist(wristSallyPull); //used to push down harder on sally
			}
			count ++;
		break;
		case 2: //robot goes backwards at high speed to swing the door open
			timeCount += fpgaDiff;
//			encoderPosition = (encoderSallyMax - 0) * timeCount / totalTime + 0;
//			speed = ((encoderSallyMax - 0) / totalTime) / SPEED_FACTOR;
////			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
//			Robot.robotDrive.setRightMotor(-1);
//			Robot.robotDrive.setLeftMotor(-1);
//			if (Robot.robotDrive.getRightEncoder() > encoderSallyMax) {
//				Robot.robotDrive.setRightMotor(0);
//				Robot.robotDrive.setLeftMotor(0);
//				sallyState++;
//				timeCount = 0;
//				totalTime = 1.0;
//			}
			if (Robot.robotDrive.goToDistance(-127, -127, 0.85, 40, 5, 0.5, 0.7)) { //was 0.75 for max and 5 for ramp up 
				Robot.robotDrive.setRightMotor(0);
				Robot.robotDrive.setLeftMotor(0);
				sallyState++;
				timeCount = 0;
				totalTime = 1.0;
			}
		break;
		case 3: //gives a slight delay before switching directions, without this the robot would quit
			timeCount++;
			if (timeCount > 15) {
				Robot.robotDrive.resetGoToDistanceState();
				sallyState++;
			}
			
			break;
		case 4://moves robot at a high speed forward to get past the sally port door, the front light sensor will indicate when we are done
//			encoderPosition = (0 - encoderSallyMax) * timeCount / totalTime + encoderSallyMax;
//			speed = ((0 - encoderSallyMax) / totalTime) / SPEED_FACTOR;
////			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
//			Robot.robotDrive.setRightMotor(1);
//			Robot.robotDrive.setLeftMotor(1);
			Robot.robotDrive.goToDistance(1000, 1000, 0.95, 5, 5, 0.9, 0.9);
			if (Robot.robotDrive.getFrontLightSensorValue() > 1250) {//indicates front is on the outer work, this means the routine is done
				sallyState++;
				Robot.robotDrive.setRightMotor(0);
				Robot.robotDrive.setLeftMotor(0);
				timeCount = 0;
				totalTime = 1.0;
				Robot.robotDrive.resetGoToDistanceState();
				return true;
			}
			timeCount += 0.02; //don't use this anymore
//			if (Robot.robotDrive.getRightEncoder() < 0) {
//				sallyState++;
//				Robot.robotDrive.setRightMotor(0);
//				Robot.robotDrive.setLeftMotor(0);
//				timeCount = 0;
//				totalTime = 1.0;
//				return true;
//			}
			break;		
		}
		return false;	
	}
	public boolean drawBridge() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA;
		lastFPGA = Timer.getFPGATimestamp();
		System.out.println("ACTUAL TIME: " + Timer.getFPGATimestamp());
		switch(drawBridgeState) {
		case 0: // again moves the wrist first so that the arm doesn't scrap against the drawbridge
			Robot.robotDrive.resetEncoders();
			setManipulatorWrist(drawBridgeWristReady);
			if (manipulatorWrist.getError() < 1000 && count > 10) { // this determines if the wrist is in position, if so it moves the elbow
				drawBridgeState++;
				count = 0;
			}
			count++;
			break;
		case 1: //moves the elbow until its in position, then moves on to next state
			setManipulatorElbow(drawBridgeElbowReady); 
			if (manipulatorElbow.getError() < 200 && count > 10) {
				drawBridgeState++;
				count = 0;
			}
			count++;
			break;
		case 2: //sets the wrist to power mode and gives is 10% power downwards to start opening the drawbridge.
			manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus); //power mode (values between -1 and 1)
			manipulatorWrist.set(0.1);
			drawBridgeState++;
			timeCount = 0;
			totalTime = 0.75; //this indicates how long the next step has to finish (lowering this will make it go faster)
			break;
		case 3: //calculates the next elbow and drivetrain position based on time, updates speed every 50th of a second, this step pulls bridge half way down, and drives back a little
			timeCount += fpgaDiff; //keeps track of time
			newElbowPosition = (elbowSecondPosition - drawBridgeElbowReady) * timeCount / totalTime + drawBridgeElbowReady; //new elbow position
			setManipulatorElbow(newElbowPosition); //set manipulator to new position
			encoderPosition = encoderSecondPosition * timeCount / totalTime;
			speed = (encoderSecondPosition / totalTime) / SPEED_FACTOR; //speed of drivetrain
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed); //makes robot drive on specified path.
			
			if (timeCount > totalTime) { //if time exceeds that specified in previous state it moves on to the next and sets a time limit for the next step
				manipulatorWrist.changeControlMode(TalonControlMode.Position); //changes wrist to position mode
				setManipulatorWrist(wristSecondPosition); //makes wrist maintain current position
				timeCount = 0;
				totalTime = 0.75;
				drawBridgeState++;
			}
			if (manipulatorWrist.get() > wristSecondPosition - 500) { //checks if manipulator reaches next target before this step finishes it maintains that position
				manipulatorWrist.changeControlMode(TalonControlMode.Position);
				setManipulatorWrist(wristSecondPosition);
			}
			break;
		case 4: //pushes arm forward and downwards to push drawbridge fully down, drivetrain doesn't move in this step
			timeCount += fpgaDiff;
			//Robot.robotDrive.DrivePath(encoderSecondPosition, 0, encoderSecondPosition, 0); //stop
			newElbowPosition = (elbowThirdPosition - elbowSecondPosition) * timeCount / totalTime + elbowSecondPosition;
			newWristPosition = (wristThirdPosition - wristSecondPosition) * timeCount / totalTime + wristSecondPosition;
			encoderPosition = (encoderThirdPosition - encoderSecondPosition) * timeCount / totalTime + encoderSecondPosition;
			speed = ((encoderThirdPosition - encoderSecondPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.5; //next step only get 1/2 second to finish
			}
			break;
		case 5: //pushes arm out a bit more to keep drawbridge down, and begins to drive forward
			timeCount += fpgaDiff;
			//Robot.robotDrive.DrivePath(encoderThirdPosition, 0, encoderThirdPosition, 0); //stop
			newElbowPosition = (elbowFourthPosition - elbowThirdPosition) * timeCount / totalTime + elbowThirdPosition;
			newWristPosition = (wristFourthPosition - wristThirdPosition) * timeCount / totalTime + wristThirdPosition;
			encoderPosition = (encoderFourthPosition - encoderThirdPosition) * timeCount / totalTime + encoderThirdPosition;
			speed = ((encoderFourthPosition - encoderThirdPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.75;
				manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus);
				manipulatorWrist.set(0);
			}
			break;
		case 6: //drive forward the rest of the way
			timeCount += fpgaDiff;
			newElbowPosition = (elbowFifthPosition - elbowFourthPosition) * timeCount / totalTime + elbowFourthPosition;
			//newWristPosition = (wristFifthPosition - wristFourthPosition) * timeCount / totalTime + wristFourthPosition;
			encoderPosition = (encoderFifthPosition - encoderFourthPosition) * timeCount / totalTime + encoderFourthPosition;
			speed = ((encoderFifthPosition - encoderFourthPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			//setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.3;
			}
			break;
		case 7: //moves elbow up a little bit so it doesn't get stuck under the robot
			timeCount += fpgaDiff;
			newElbowPosition = (elbowSixthPosition - elbowFifthPosition) * timeCount / totalTime + elbowFifthPosition;
			setManipulatorElbow(newElbowPosition);
			Robot.robotDrive.DrivePath(encoderFifthPosition, 0, encoderFifthPosition, 0); //stop
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 1.0;
			}
			break;
		case 8: //stops the drivetrain so it doesn't continue at previous speed
			manipulatorWrist.changeControlMode(TalonControlMode.Position);
			Robot.robotDrive.DrivePath(encoderFifthPosition, 0, encoderFifthPosition, 0); //stop
			return true;
		}
		System.out.println("Case: " + drawBridgeState + ", " + "Angular wrist: " + Robot.manipulatorArm.getManipulatorWristAngular() + ", " + "Wrist encoder: " + Robot.manipulatorArm.getManipulatorWristPosition());
		return false;
	}
	public boolean portcullis() {
		switch(portcullisState) {
		case 0:
			setManipulatorWrist(wristPortcullisReady);
			timeCount = 0;
			totalTime = 0.5;
			portcullisState++;
			break;
		case 1:
			encoderPosition = encoderPortcullisFirst * timeCount / totalTime;
			speed = (encoderPortcullisFirst / totalTime) / SPEED_FACTOR; //encoderPortcullisFirst
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			timeCount += 0.02;
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 2:
			encoderPosition = encoderPortcullisFirst; //* timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisReady - Robot.manipulatorElbowRestPosition()) * timeCount / totalTime + Robot.manipulatorElbowRestPosition();
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 3:
			encoderPosition = encoderPortcullisFirst;// * timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisSecond - elbowPortcullisReady) * timeCount / totalTime + elbowPortcullisReady;
			newWristPosition = (wristPortcullisSecond - wristPortcullisReady) * timeCount / totalTime + wristPortcullisReady;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 4:
			encoderPosition = encoderPortcullisFirst;// * timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisThird - elbowPortcullisSecond) * timeCount / totalTime + elbowPortcullisSecond;
			newWristPosition = (wristPortcullisThird - wristPortcullisSecond) * timeCount / totalTime + wristPortcullisSecond;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 5:
			encoderPosition = (encoderPortcullisSecond - encoderPortcullisFirst) * timeCount / totalTime + encoderPortcullisFirst;
			speed = ((encoderPortcullisSecond - encoderPortcullisFirst) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisFourth - elbowPortcullisThird) * timeCount / totalTime + elbowPortcullisThird;
			newWristPosition = (wristPortcullisFourth - wristPortcullisThird) * timeCount / totalTime + wristPortcullisThird;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 6:
			encoderPosition = (encoderPortcullisThird - encoderPortcullisSecond) * timeCount / totalTime + encoderPortcullisSecond;
			speed = ((encoderPortcullisThird - encoderPortcullisSecond) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 7:
			encoderPosition = (encoderPortcullisThird);
			speed = ((0) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			return true;
		}
		return false;
	}
	public void exitSallyPort() { //give specified movement when exiting the sally port early so it doesn't just push down on the door really hard
		switch(exitSallyState) {
		case 0: //moves the manipulator to be straight up
			setManipulatorWrist(wristStraightUpPosition);
			setManipulatorElbow(elbowStraightUpPosition);
			if (manipulatorWrist.getError() < 100 && count > 10) { //once wrist is in the right position it moves to next step
				exitSallyState++;
				count = 0;
			}
			count ++;
			break;
		case 1: //moves elbow to rest position, then sets the wrist
			setManipulatorElbow(Robot.manipulatorElbowRestPosition());
			if (manipulatorElbow.getError() < 20000 && count > 10) {
				exitSallyState = 0;
				count = 0;
				setManipulatorMode("Rest" );
			}
			count ++;
		}
		
	}
	public void calibrateManipulator() {
		
	}
	
	
	
//	public static boolean lookup(double time){ // do a lookup of the position information and also calculate speed data
//	// First, find the correct time offset into the data
//	int x, arysize;
//	double time_accumulator = 0, find_time = 0;
//	double start_time = 0, end_time = 0;
//	boolean found,done;
//	double start_pos1 = 0, end_pos1 = 0, pos1 = 0, speed1 = 0;
//	double start_pos2 = 0, end_pos2 = 0, pos2 = 0, speed2 = 0;
//	double start_pos3 = 0, end_pos3 = 0, pos3 = 0, speed3 = 0;
//	double start_pos4 = 0, end_pos4 = 0, pos4 = 0, speed4 = 0;
//	
//	double speed_multiplier = speed_mult;
//	
//	double timeoffset = time * speed_multiplier;
//	
//	int dataset = comboindex;
//	// Now, try to look this up in the correct dataset
//	if (dataset == 0)
//	    arysize = portcullis.length;
//	else if (dataset == 1)
//	    arysize = cheval.length; 
//	else if (dataset == 2)
//	    arysize = sally.length; 
//	else if (dataset == 3)
//	    arysize = drawbridge.length; 
//	else
//	    return false; // dataset is out of range.  Return false.  Lookup fails
//	
//	found = false; // Indicate we have not yet found the dataset elements in the desired time range
//	done = false;
//	x = 0;
//	time_accumulator = 0.0;
//	find_time = time * speed_multiplier;
//	while((!found)&&(!done)) {
//	    switch(dataset) {
//	        case 0: // portcullis
//	            start_time = time_accumulator;
//	            end_time = time_accumulator + portcullis[x][joints.TIME.ordinal()];
//	            if ((find_time >= start_time)&&(find_time < end_time))
//	                { // If we are in the right time space, set up data for each axis
//	                start_pos1 = portcullis[x][joints.WRIST.ordinal()];
//	                end_pos1 = portcullis[x+1][joints.WRIST.ordinal()];
//	                start_pos2 = portcullis[x][joints.ELBOW.ordinal()];
//	                end_pos2 = portcullis[x+1][joints.ELBOW.ordinal()];
//	                start_pos3 = portcullis[x][joints.LEFT.ordinal()];
//	                end_pos3 = portcullis[x+1][joints.LEFT.ordinal()];
//	                start_pos4 = portcullis[x][joints.RIGHT.ordinal()];
//	                end_pos4 = portcullis[x+1][joints.RIGHT.ordinal()];
//	                found = true;
//	                }
//	            else if (x >= arysize - 2)
//	                done = true; // We have reached the end of the dataset.  Motion is done.
//	            break;
//	        case 1: // cheval
//	            start_time = time_accumulator;
//	            end_time = time_accumulator + cheval[x][joints.TIME.ordinal()];
//	            if ((find_time >= start_time)&&(find_time < end_time))
//	                { // If we are in the right time space, set up data for each axis
//	                start_pos1 = cheval[x][joints.WRIST.ordinal()];
//	                end_pos1 = cheval[x+1][joints.WRIST.ordinal()];
//	                start_pos2 = cheval[x][joints.ELBOW.ordinal()];
//	                end_pos2 = cheval[x+1][joints.ELBOW.ordinal()];
//	                start_pos3 = cheval[x][joints.LEFT.ordinal()];
//	                end_pos3 = cheval[x+1][joints.LEFT.ordinal()];
//	                start_pos4 = cheval[x][joints.RIGHT.ordinal()];
//	                end_pos4 = cheval[x+1][joints.RIGHT.ordinal()];
//	                found = true;
//	                }
//	            else if (x >= arysize - 2)
//	                done = true; // We have reached the end of the dataset.  Motion is done.
//	            break;
//	        case 2: // sally
//	            start_time = time_accumulator;
//	            end_time = time_accumulator + sally[x][joints.TIME.ordinal()];
//	            if ((find_time >= start_time)&&(find_time < end_time))
//	                { // If we are in the right time space, set up data for each axis
//	                start_pos1 = sally[x][joints.WRIST.ordinal()];
//	                end_pos1 = sally[x+1][joints.WRIST.ordinal()];
//	                start_pos2 = sally[x][joints.ELBOW.ordinal()];
//	                end_pos2 = sally[x+1][joints.ELBOW.ordinal()];
//	                start_pos3 = sally[x][joints.LEFT.ordinal()];
//	                end_pos3 = sally[x+1][joints.LEFT.ordinal()];
//	                start_pos4 = sally[x][joints.RIGHT.ordinal()];
//	                end_pos4 = sally[x+1][joints.RIGHT.ordinal()];
//	                found = true;
//	                }
//	            else if (x >= arysize - 2)
//	                done = true; // We have reached the end of the dataset.  Motion is done.
//	            break;
//	        case 3: // drawbridge
//	            start_time = time_accumulator;
//	            end_time = time_accumulator + drawbridge[x][joints.TIME.ordinal()];
//	            if ((find_time >= start_time)&&(find_time < end_time))
//	                { // If we are in the right time space, set up data for each axis
//	                start_pos1 = drawbridge[x][joints.WRIST.ordinal()];
//	                end_pos1 = drawbridge[x+1][joints.WRIST.ordinal()];
//	                start_pos2 = drawbridge[x][joints.ELBOW.ordinal()];
//	                end_pos2 = drawbridge[x+1][joints.ELBOW.ordinal()];
//	                start_pos3 = drawbridge[x][joints.LEFT.ordinal()];
//	                end_pos3 = drawbridge[x+1][joints.LEFT.ordinal()];
//	                start_pos4 = drawbridge[x][joints.RIGHT.ordinal()];
//	                end_pos4 = drawbridge[x+1][joints.RIGHT.ordinal()];
//	                found = true;
//	                }
//	            else if (x >= arysize - 2)
//	                done = true; // We have reached the end of the dataset.  Motion is done.
//	            break;
//	        }
//	    if ((!found)&&(!done)) // keep looking till we're done or till we find what we're looking for.
//	        {
//	        x++;
//	        time_accumulator = end_time;
//	        }
//	    }
//	if ((found)&&(!done)) // If we are not done and we found a record, generate data.
//	    { // We have valid data points.  Calculate target positions and speeds.
//	    pos1 = interp(find_time, start_time, end_time, start_pos1, end_pos1); // interpolate for pos1
//	    // Calculate speed assuming we will maintain the same average speed for this section
//	    speed1 = (end_pos1 - start_pos1) / (end_time - start_time) * speed_multiplier / 5.0;
//	
//	    pos2 = interp(find_time, start_time, end_time, start_pos2, end_pos2); // interpolate for pos2
//	    speed2 = (end_pos2 - start_pos2) / (end_time - start_time) * speed_multiplier / 5.0;
//	
//	    pos3 = interp(find_time, start_time, end_time, start_pos3, end_pos3); // interpolate for pos2
//	    speed3 = (end_pos3 - start_pos3) / (end_time - start_time) * speed_multiplier / 5.0;
//	
//	    pos4 = interp(find_time, start_time, end_time, start_pos4, end_pos4); // interpolate for pos2
//	    speed4 = (end_pos4 - start_pos4) / (end_time - start_time) * speed_multiplier / 5.0;
//	
//	    wristPos = pos1;
//	    elbowPos = pos2;
//	    leftPos = pos3;
//	    rightPos = pos4;
//	    wristSpeed = speed1;
//	    elbowSpeed = speed2;
//	    leftSpeed = speed3;
//	    rightSpeed = speed4;
//	    return true; // Data has been set.  Return True.
//	    }
//	else // if we can't find something or we are done, return false.  Motion is to stop now.
//	    return false;
//	}

//public static void posPrint(double timeStep) {
//	double localTime=0;
//	while (lookup(localTime))
//    {
//    System.out.printf("time = %3.2f" + ", wrist pos = %5.2f "+" speed = %3.2f " +
//                    ", elbow pos = %6.2f "+" speed = %3.2f " +
//                    ", left pos = %3.2f "+" speed = %3.2f " +
//                    ", right pos = %3.2f "+" speed = %3.2f "+"\n", localTime, wristPos, wristSpeed, elbowPos, elbowSpeed, leftPos, leftSpeed, rightPos, rightSpeed);
//    localTime = localTime +timeStep;
//
//    }
//}

}



