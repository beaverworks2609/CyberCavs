// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.subsystems;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;
import org.usfirst.frc4678.Cybercavs2016Code.RobotMap;
import org.usfirst.frc4678.Cybercavs2016Code.commands.DriveTrain;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class RobotDrive extends Subsystem {

	double powerReduction = 0.6;
	boolean robotDriving = false;
	double GO_TO_DISTANCE_CORRECTION_SPEED = 50;
	int AUTO_DRIVE_RAMP_DISTANCE = 30;
	double encoderClicksPerCentimeter = 7.2;
//	int ENCODER_DIFFERENCE_PER_TURN = Robot.encoderChangePerTurn();
//	int LIGHT_SENSOR_MARGIN = Robot.lightSensorMargin();
//	double GO_TO_BOX_TURN_SPEED = Robot.goToBoxTurnSpeed();
//	int TARGET_LIGHT_SENSOR_VALUE = Robot.targetLightSensorValue();
	double AUTO_TURN_MARGIN = .05;// This is a percentage
//	double AUTO_TURN_REDUCTION_SPEED = Robot.autoTurnReductionSpeed();
	double AUTO_TURN_REDUCTION_DISTANCE = 0.6;// Starts reducing the speed when
												// it is x percent of the way to
												// the target distance
	long goalTime;
	int timedDriveState = 0;
	int goToDistanceState = 0;
	int turnState = 0;
	int startingLeftDistance;
	int startingRightDistance;
	boolean gentleModeOn = true;
	// GoToDistance variables
	double targetLeft;
	double targetRight;
	double currentLeft;
	double currentRight;
	double currentLeftCentimeters;
	double currentRightCentimeters;
	double leftPercentThere;
	double rightPercentThere;
	double leftMotorMultiplier;
	double rightMotorMultiplier;
	double powerOffset;
	double gyroTarget = 0;
	double gyroError;
	double gyroPower = 0.75;
	double previousAccelVal = 1000;
	double leftPower = 0;
	double rightPower = 0;
	int count = 0;
	boolean Auton;
	double previousRightEnc = 0;
	double previousLeftEnc = 0;
	double cameraXPos = 0;
	int chevalState = 0;
	
	boolean isinAuto = true;
	int retrycount = 0;
	
	
	private final NetworkTable grip = NetworkTable.getTable("GRIP");
	private double WIDTH = 320.0;
	private double CENTERX = (WIDTH / 2) - 0; //decreaing makes robot go to the right
	//private double PIXEL_ENCODER_RATIO = Robot.pixelsPerEncoderChange();
//	private double AUTOAIM_TURN_RATE = Robot.autoAimTurnRate();
//	private double AUTOAIM_MAX_POWER = Robot.autoAimMaxPower();
	private double[] currentCenterXs,currentCenterYs;
	private double MAXCENTERY = 90; // Ignore objects where Y co-ord is less than this value.  Won't see targets higher
									// in the field of vision (ignore lights on the ceiling)
									// 100 was good at Fall Fiesta.  0 would include everything.  240 would eliminate everything.
	private double[] currentWidths,currentHeights;
	//private double ratioWH; // ratio of width / height.  We want relatively square objects (ratio between 0.75 and 1.25)
	private double MINWH = 1.0;
	private double MAXWH = 1.60;
	private double MINWID = 25;
	private double MAXWID = 55;
	private double MINHT = 15;
	private double MAXHT = 45;
	
	enum AutoAimState {
		INITIAL,
		MOVING,
		FINISHED
	}
	
	private int state = 0;
	private int cnt = 0;
	private double widest = 0;
	private int wideidx = 0;
	private double closest = 0;
	private int closeidx = 0;
	private int closecnt = 0;
	private double pixelsToTurn;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftMotor = RobotMap.robotDriveleftMotor;
    private final SpeedController rightMotor = RobotMap.robotDriverightMotor;
    private final Encoder leftEncoder = RobotMap.robotDriveleftEncoder;
    private final Encoder rightEncoder = RobotMap.robotDriverightEncoder;
    private final AnalogGyro turnGyro = RobotMap.robotDriveturnGyro;
    private final AnalogInput frontLightSensor = RobotMap.robotDrivefrontLightSensor;
    private final AnalogInput backLightSensor = RobotMap.robotDrivebackLightSensor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final Accelerometer accel = RobotMap.accel;
	private final Gyro gyro = RobotMap.gyro;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveTrain());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	//////////////////////////////////////
	////////// Access Functions//////////
	/////////////////////////////////////
	
	public int getLeftEncoder() {return leftEncoder.get();}

	public int getRightEncoder() {return rightEncoder.get();}

	public double getBuiltInAccelX() {return accel.getX();}

	public double getBuiltInAccelY() {return accel.getY();}

	public double getBuiltInAccelZ() {return accel.getZ();}
	
	public double getFrontLightSensorValue() {return frontLightSensor.getValue();}

	public double getBackLightSensorValue() {return backLightSensor.getValue();}
	
	public double getGyroPosition() {return turnGyro.getAngle();}
	
	public double getRightPower() {return rightPower;}
	
	public double getLeftPower() {return leftPower;}
	
	public double getGyroAngle() {return gyro.getAngle();}
	
	/////////////////////////////////////
	////////// Setter functions//////////
	/////////////////////////////////////
	
	public void setRightMotor(double power) {
		rightMotor.set(power);
		rightPower = power;
	}

	public void setLeftMotor(double power) {
		leftMotor.set(-power);
		leftPower = power;
	}
	
	public void resetGyro() {
		gyro.reset();
	}
	
	public void setRightTarg(double target) {
		targright = target;
	}
	public void setLeftTarg(double target) {
		targleft = target;
	}
	public void resetGoToDistanceState() {
		goToDistanceState = 0;
	}
	public void setIsInAuto(boolean val) {
		isinAuto = val;
	}
	public void resetChevalState() {
		chevalState = 0;
	}
	public void resetCount() {
		count = 0;
	}
	
	/////////////////////////////////////////
	//////////autonomous functions//////////
	///////////////////////////////////////
	
	// To use this method, you keep calling it until it returns true
	public boolean goToDistance(double rightCentimeters,
			double leftCentimeters, double power, int rampUpDistance,
			int rampDownDistance, double startingPower, double endingPower) {
		SmartDashboard.putNumber("Left Wheels Position",
				Robot.robotDrive.getLeftEncoder());
		SmartDashboard.putNumber("Right Wheels Position",
				Robot.robotDrive.getRightEncoder());

		// --------------------------------------------------------------------------
		// -----------------------Reset variables if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// If this method is being called for the first time since it last
		// finished, you want to record the initial encoder values
		if (goToDistanceState == 0) {
			goToDistanceState++;
			startingLeftDistance = getLeftEncoder();
			startingRightDistance = getRightEncoder();
			// Robot.logger.info("Drivetrain",
			// "goToDistance starting encoder values are " + getRightEncoder() +
			// ", " + getLeftEncoder());
		}

		System.out.println("hi goToDistanceState=" + goToDistanceState + " "
				+ startingLeftDistance + " " + startingRightDistance);

		// --------------------------------------------------------------------------
		// ---------------------Get target and current
		// distances---------------------
		// --------------------------------------------------------------------------

		// Get target distance in centimeters
		targetLeft = leftCentimeters * encoderClicksPerCentimeter; //used to be parameters
		targetRight = rightCentimeters * encoderClicksPerCentimeter; //used to be parameters

		// Get the current distance in centimeters
		currentLeft = Math.abs(getLeftEncoder() - startingLeftDistance);
		currentRight = Math.abs(getRightEncoder() - startingRightDistance);
		currentLeftCentimeters = currentLeft
				/ encoderClicksPerCentimeter; //used to use the parameter
		currentRightCentimeters = currentRight
				/ encoderClicksPerCentimeter; //used to use the parameter (same name)

		// Find the percentage the left and right are to their target
		leftPercentThere = Math.abs(currentLeft / targetLeft);
		rightPercentThere = Math.abs(currentRight / targetRight);
		// Robot.logger.debug("Drivetrain", "gpToDistance Percentages At " +
		// rightPercentThere + ", " + leftPercentThere);

		// Initially set the powers to their default values
		leftMotorMultiplier = 1;
		rightMotorMultiplier = 1;

		// --------------------------------------------------------------------------
		// ----------------Adjust powers if one side has gone
		// farther----------------
		// --------------------------------------------------------------------------

		// Difference between how far the left and right have gone
		powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED
				* Math.abs(leftPercentThere - rightPercentThere);

		// Only start adjusting the powers once the motors have gone 2 percent
		// of the target distance, to avoid calculation errors
		if (currentRight >= (targetRight * 0.02)
				&& (currentLeft >= (targetLeft * 0.02))) {
			// If the right is closer than the left, increase the left power and
			// decrease the right power
			if (rightPercentThere > (leftPercentThere + 0.001)) {
				leftMotorMultiplier *= 1 + powerOffset;
				rightMotorMultiplier *= 1 - powerOffset;
			}

			// If the left is closer than the right, increase the right power,
			// and decrease the left power
			if ((rightPercentThere + 0.001) < leftPercentThere) {
				leftMotorMultiplier *= 1 - powerOffset;
				rightMotorMultiplier *= 1 + powerOffset;
			}
		}
		// Robot.logger.debug("Drivetrain", "goToDistance percentages at " +
		// (int)(rightPercentThere * 100) + ", " + (int)(leftPercentThere * 100)
		// + " Power Offset At " + (((int)(1000 * powerOffset)) / 1000.0));

		// --------------------------------------------------------------------------
		// -----------------------Flip the powers if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// We use the absolute values for setting the powers, so we have to flip
		// the powers based on what direction the robot is going
		if (targetRight < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		}

		if (targetLeft < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		}

		// --------------------------------------------------------------------------
		// -----------------------------Ramp Down
		// Speeds-----------------------------
		// --------------------------------------------------------------------------

		double rampDownPercentage = 1;
		if (currentRightCentimeters < rampUpDistance) {
			rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower))
					+ startingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		} else if (currentRightCentimeters > Math.abs(rightCentimeters)
				- rampDownDistance) {
			rampDownPercentage = (((Math.abs(rightCentimeters) - currentRightCentimeters) / rampDownDistance) * (1 - endingPower))
					+ endingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		}

		// Robot.logger.debug("Drivetrain", "goToDistance target is " +
		// rightCentimeters + ", " + leftCentimeters + " current is " +
		// (-(int)((getRightEncoder() - startingRightDistance) /
		// Robot.encoderClicksPerCentimeter())) + ", " +
		// (-(int)((getLeftEncoder() - startingLeftDistance) /
		// Robot.encoderClicksPerCentimeter())));

		setLeftMotor(leftMotorMultiplier * power * rampDownPercentage);
		setRightMotor(rightMotorMultiplier * power * rampDownPercentage);

		// If the left and the right both have gone far enough stop the motors,
		// and reset the goToDistanceState so that the next time
		// the method is called, it will record the starting encoder values
		// again
		if (rightPercentThere >= 1 && leftPercentThere >= 1) {
			setLeftMotor(0);
			setRightMotor(0);
			goToDistanceState = 0;
			//System.out.println("Drivetrain goToDistance at target");
			//System.out.println("Drivetrain goToDistance final encoder values are "+ getRightEncoder() + ", " + getLeftEncoder());
			return true;
		}
		System.out.println(" return false here...");

		return false;
	}

	public boolean isFlat() {
		if (checkFrontLightSensorIsOnCarpet()
				&& checkBackLightSensorIsOnCarpet()) {
			return true;
		} else {
			return false;
		}
	}
	
	public double gyro_I = 0;
	public double MAXGYROPOWER = 0.4;

	public boolean gyroTurn(double target) {
		gyroTarget = target;
		gyroError = gyroTarget - gyro.getAngle();
		if (gyroError > 7.0) {
			gyro_I = 0.0;
		} else
			gyro_I += gyroError * 0.005; // At 7.0 error, this is 0.007 in 0.25 seconds, 
		gyroPower = gyroError * 0.03 + gyro_I; // 0.0067 was pretty good
		if (gyroPower > MAXGYROPOWER)
			gyroPower = MAXGYROPOWER;
		if (gyroPower < -MAXGYROPOWER)
			gyroPower = -MAXGYROPOWER;
		setLeftMotor(gyroPower);
		setRightMotor(-gyroPower);
		if (Math.abs(gyroError) < 5) {
			Robot.robotDrive.setLeftMotor(0);
			Robot.robotDrive.setRightMotor(0);
			return true;
		}
		System.out.println(gyroError + ", " + gyro_I + ", " + gyroPower);
		return false;

	}

	public boolean checkFrontLightSensorIsOnCarpet() {
		if (frontLightSensor.getValue() < 1000) {
			return true;
		} else {
			return false;
		}
	}

	public boolean checkBackLightSensorIsOnCarpet() {
		if (backLightSensor.getValue() < 1000) {
			return true;
		} else {
			
			return false;
		}
	}
	
	public double getLeftSpeed() {
		return leftEncoder.getRate();
	}
	public double getRightSpeed() {
		return rightEncoder.getRate();
	}
    
	public void resetEncoders() {
		leftEncoder.reset();
		rightEncoder.reset();
	}
	
	public void setTurnPower(double power) {
    	setLeftMotor(power);
    	setRightMotor(-power);
    }
    
	public void autoAimInit() {
    	state = 0;//AutoAimState.INITIAL;
    	cnt = 0;
    }
    
    public void setTarget(double left, double right) {
    	targleft = left;
    	targright = right;
    }
    
    int prevRightEnc[] = new int[16];
    int prevLeftEnc[] = new int[16];
    int enccnt = 0;
    double prevCenterX;
    double pixelsToTarget = 0;

    // 1.4 pixels / encoder click (both wheels)
    public boolean autoAim() {
    	double leftDiff = previousLeftEnc - leftEncoder.get();
    	double rightDiff = previousRightEnc - rightEncoder.get();
        int x;
        double pctdiff = 0.0;
    	previousLeftEnc = leftEncoder.get();
    	previousRightEnc = rightEncoder.get();
    	switch(state) {
    		case 0:
    			cnt = 0;
    			retrycount = 0;
    			state++;
    			break;
    		case 1:
    			if (leftDiff == 0 && rightDiff == 0) {
    				cnt++;
    			}
    			if (cnt > 5) {
    				state++;
    				cnt = 0;
    			}
    			break;
    		case 2: // Init for Camera auto aim
    			currentCenterXs = grip.getNumberArray("myContoursReport/centerX", new double[]{});
    			currentCenterYs = grip.getNumberArray("myContoursReport/centerY", new double[]{});
    			currentWidths = grip.getNumberArray("myContoursReport/width",new double[]{});
    			currentHeights = grip.getNumberArray("myContoursReport/height",new double[]{});
	    		//System.out.println("Looking for contours" + currentCenterXs.length);    	    	
    			if (currentCenterXs.length == 0) {
    	    		setTurnPower(0);
    	    		cnt = 0;
    	    		break;
    	    	}
    	    	else {
    	    		//System.out.println("Found at least 1");
    	    		cnt++; // Increment counter.  If we get readings 5 times in a row, assume target is good
    	    		if (cnt >= 8) {
    	    			state++;
    	    			cnt = 0;
    	    			widest = 0;
    	    			pixelsToTurn = 0;
    	    			while((cnt < currentCenterXs.length && cnt < currentCenterYs.length && cnt < currentWidths.length && cnt < currentHeights.length)) {
    	    				System.out.println("01: WIDTHS: " + currentWidths[cnt] + "HEIGHTS: " + currentHeights[cnt]);
    	    				if ((currentWidths[cnt] > widest)&&(currentCenterYs[cnt] > MAXCENTERY)&&(currentWidths[cnt] > MINWID)&&(currentWidths[cnt]<MAXWID)&&(currentHeights[cnt] > MINHT)&&(currentHeights[cnt] < MAXHT)) {
        	    				System.out.println("1: WIDTHS: " + currentWidths[cnt] + "HEIGHTS: " + currentHeights[cnt]);
    	    					widest = currentWidths[cnt];
    	    					wideidx = cnt;
    	   	        	    	pixelsToTurn = currentCenterXs[wideidx] - CENTERX;
                                prevCenterX = currentCenterXs[wideidx]; // use to detect when currentCenterX changes.
    	    				}
    	    				cnt++;
    	    			}

    	    		}
    	    	}
    	    	break;
    		case 3: // Target is good, find largest width value and use that as target
    			// 0.735 is a pretty good multiplier when close to target.  When far away, we need a lower multiplier
    			// Center is 173.
    			// Target X,  Encoder Left start,  Encoder Right start, Encoder left end, Encoder Right end
    			// 142, 0, 0, -30, -58 , avg = -44
    			// 209, 83, 108, 89, 70, avg = -16
    			// 95, 120, -9, 33, 25
    			// 
    			cnt = 0;

    	    	// try mult = 0.735 for pixelsToTurn at 10 Going with 0.74
    	    	// try mult = 0.7 for pixelsToTurn at 40 seemed to work ok.
    			// changing pixels to turn formula to work for 100 pixels at max and 10 picels at min.
    			// Min at 0.74 encoder to pixel calc.  Max at 
    	    	double pixelmult = (Robot.pixelsPerEncoderChange() - Robot.pixToTurnMax())*(Math.abs(pixelsToTurn) - 10)/90.0 + Robot.pixToTurnMax() ;
    	    	resetEncoders();
    	    	targleft = -pixelsToTurn * pixelmult;
    	    	System.out.println("pixelmult = "+pixelmult);
    	    	targright = -targleft;
    	    	System.out.println("pixelsToTurn:" + pixelsToTurn+" pixelmult= "+ pixelmult +" CENTERX = "+CENTERX+" Targets("+targleft+","+targright+")");
                enccnt = 0; // Count number of encoder readings.  Make sure we have at least 5 before we evaluate camera CenterX change.
    			state++;
    			break;
    		case 4:
				cameraXPos = 0;
    			currentCenterXs = grip.getNumberArray("myContoursReport/centerX", new double[]{});
    			currentCenterYs = grip.getNumberArray("myContoursReport/centerY", new double[]{});
    			currentWidths = grip.getNumberArray("myContoursReport/width",new double[]{});
    			currentHeights = grip.getNumberArray("myContoursReport/height",new double[]{});
					// Find the CenterX closest to CENTERX and see how close we are.
//    			closecnt = 0;
//    			closest = 10000.0;
//    			while(closecnt < currentCenterXs.length) {
//    				double tmp = Math.abs(currentCenterXs[closecnt] - CENTERX);
//    				if ((tmp < closest)&&(currentCenterYs[closecnt] < 240)) {
//    					closest = tmp;
//    					closeidx = closecnt;
//    					cameraXPos = currentCenterXs[closecnt]; // This is the closest contour as the robot is turning.
//    				}
//    				closecnt++;
//    			}
    			
    			// Find closest seems to cause problems.  Find the widest.  This should work better.
    			cnt = 0;
    			widest = 0;
    			pixelsToTurn = 0;
    			while(cnt < currentCenterXs.length && cnt < currentCenterYs.length && cnt < currentWidths.length && cnt < currentHeights.length) {
    				System.out.println("02: WIDTHS: " + currentWidths[cnt] + "HEIGHTS: " + currentHeights[cnt]);
    				if ((currentWidths[cnt] > widest)&&(currentCenterYs[cnt] > MAXCENTERY)&&(currentWidths[cnt] > MINWID)&&(currentWidths[cnt]<MAXWID)&&(currentHeights[cnt] > MINHT)&&(currentHeights[cnt] < MAXHT)) {
        				System.out.println("2: WIDTHS: " + currentWidths[cnt] + "HEIGHTS: " + currentHeights[cnt]);
    					widest = currentWidths[cnt];
    					wideidx = cnt;
   	        	    	// pixelsToTurn = currentCenterXs[wideidx] - CENTERX;
                        cameraXPos = currentCenterXs[cnt]; // use to detect when currentCenterX changes.
    				}
    				cnt++;
    			}
    			
				System.out.println("Encoders during findTarget"+ Robot.robotDrive.getRightEncoder() + ", " + Robot.robotDrive.getLeftEncoder() + " cameraXPos = "+cameraXPos);
    			if (findTarget()) {
    				setLeftMotor(0);
    				setRightMotor(0);
    				state++;
    				cnt = 0;
    				}
                for(x = 15;x > 0;x--) {
                    prevLeftEnc[x] = prevLeftEnc[x-1]; // keep last 16 encoder left and right
                    prevRightEnc[x] = prevRightEnc[x-1]; // values so we can see where we were at when camera gets a new Center X.
                    }
                prevLeftEnc[0] = leftEncoder.get(); // Store current left and right encoder readings in element 0
                prevRightEnc[0] = rightEncoder.get(); // of the arrays.
                enccnt++; // Keep track of how many encoder readings we have
                //System.out.println("enccnt = "+enccnt);
                if (enccnt > 16) { // Make sure we have a history of encoder positions before considering camera image position updates.
                    if (prevCenterX != cameraXPos) {// Camera reports a change in the target position.  Have a look
                        // this image is where the encoders were about 5 or 6 readings ago.  Use those to see how well on-track we are.
                        // These would be prevLeftEnc[6] and prevRightEnc[6]
                        // adjust and correct the targright and targleft values on the fly to correct aim as we get closer to the target
                        // Let's start with the equivalent of pixelsToTurn
                        pixelsToTarget = cameraXPos - CENTERX; // Use new cameraXPos to determine how far we are from the target.
                        // and get that into an encoder target value using the same formula as above but use a different variable.
                        double pixelmult2 = (Robot.pixelsPerEncoderChange() - Robot.pixToTurnMax())*(Math.abs(pixelsToTarget) - 10)/90.0 + Robot.pixToTurnMax();
                        double newtargleft = -pixelmult2 * pixelsToTarget; // Calculate the new target positions as they were 5/50 seconds ago.
                        //double newtargright = -newtargleft; // ago when this camera image was taken.  This assumes a 0 encoder position when the 
                        // turn started 6/50 seconds ago so we need to see what the encoders were really reading back then.
                        // use [6] array element to have a look.  This should be pretty close so long as we're processing a 50Hz.
                        int leftEnc6 = prevLeftEnc[6];
                        int rightEnc6 = prevRightEnc[6];
                        // basically, if we are right on track, newtargleft + leftEnc6 == targleft
                        // and newtargright + rightEnc6 == targright.  Since leftEnc6 and rightEnc6 may not be perfectly in sync, we can
                        // assume the actual encoder turn was more like encoder_turned = (leftEnc6 - rightEnc6) / 2.  This is for the left encoder.
                        // we may want to leave targright and targleft alone in situations where leftEnc6 and rightEnc6 are not in sync
                        // and hopefully, the next camera reading takes place when they pretty much equal (leftEnc6 == rightEnc6)
                        // Let's calculate a correction for targleft and targright for now and print this information to see how things look.
                        
                        double encComplete = (leftEnc6 - rightEnc6) / 2; // This is how much of the turn we have completed (in encoder ticks)
                        // The sign will be correct for targleft. Since rightEnc6 should be about equal to -leftEnc6. 
                        // newtargleft + encComplete would be what we now think targleft should be.
                        // Since targright = -targleft, we don't really need
                        // to be calculating it.  We can just work with targleft and set targright = -targleft like we do in the original calculation.
                        double adjustedtargleft = newtargleft + encComplete;
                        
                        // Calculate a % diff for leftEnc6 and rightEnc6
                        // maybe just abs(leftEnc6 + rightEnc6) would be just as helpful.
                        int encSum = Math.abs(leftEnc6 + rightEnc6);
                        if (encComplete != 0) { // avoid div by 0 errors.
                            pctdiff = Math.abs(encSum) / Math.abs(encComplete); // Get an idea as to how far off left and right encoders are.
                            }
                        else
                            {
                            pctdiff = 100.0; // Assume pctdiff is large if targleft is = 0
                            }

                            // Display the data we have indicating what our new target should be.
                        System.out.println("Camera Adjustment image at "+cameraXPos+" leftEnc6="+leftEnc6+" rightEnc6="+rightEnc6+" encSum = "+encSum+" targleft="+targleft+" should be="+adjustedtargleft+" pctdiff="+pctdiff);
                        
                        // If encoders are off by less than 10%, assume we will allow a correction to the target
                        // we might just want to check if encSum < 10 instead.
                        if (pctdiff < 0.10) { // uncomment the following lines to allow for live camera target corrections to take place.
                             targleft = adjustedtargleft;
                             targright = -targleft;
                            }
                        prevCenterX = cameraXPos; // Update prevCenterX so we can detect the next camera position update.
                        }
                    }
                else {
                    prevCenterX = cameraXPos; // Make sure we only catch fresh camera update images, not the one as soon as enccnt > 16
    				}
    	    	break;
    		case 5:
    			// Robot encoders say we're at the right position.  Camera lag is about 5 of 6 cycles at 50Hz so
    			// Assume the findTarget stuff has used up 12 of those, we need to acquire the image for another 25 cycles (not really).
    			// Then assess if the position is good or not.  If not, repeat at case 3 with the new adjustment.
    			if (isinAuto) { // Only do this extra part when in Autonomous
    				cnt++; // Wait the 25 counts
    				if (cnt > 8) {
        				if (retrycount < 5) { // give up after 5 re-tries
        	    			currentCenterXs = grip.getNumberArray("myContoursReport/centerX", new double[]{});
        	    			currentCenterYs = grip.getNumberArray("myContoursReport/centerY", new double[]{});
        	    			currentWidths = grip.getNumberArray("myContoursReport/width",new double[]{});
        	    			currentHeights = grip.getNumberArray("myContoursReport/height",new double[]{});
          					// Find the CenterX closest to CENTERX and see how close we are.
        	    			closecnt = 0;
        	    			closest = 10000.0;
        	    			closeidx = -1;
        	    			while((closecnt < currentCenterXs.length) && (closecnt < currentCenterYs.length) &&(closecnt < currentWidths.length)&&(closecnt < currentHeights.length)) {
        	    				System.out.println("03: WIDTH: " + currentWidths[closecnt]);
        	    				double tmp = Math.abs(currentCenterXs[closecnt] - CENTERX);
        	    				if ((tmp < closest)&&(currentCenterYs[closecnt] > MAXCENTERY)&&(currentWidths[closecnt] > MINWID)&&(currentWidths[closecnt]<MAXWID)&&(currentHeights[closecnt] > MINHT)&&(currentHeights[closecnt] < MAXHT)) {
            	    				System.out.println("3: WIDTH: " + currentWidths[closecnt]);
        	    					closest = tmp;
        	    					closeidx = closecnt;
        	    				}
        	    				closecnt++;
        	    			}
        	    			if (currentCenterXs.length > 0 &&(closeidx >= 0)) {
	        	    			double tmp = Math.abs(currentCenterXs[closeidx] - CENTERX);
	        	    			if (tmp > 3) { // Not Close enough.  Let's try again.
	           	        	    	pixelsToTurn = currentCenterXs[closeidx] - CENTERX; // Here's how far we need to turn
	           	        	    	state = 3; // State 3 takes care of things once we've set pixelsToTurn
	           	        	    	retrycount++; // Keep track of how many times we re-try.
	        	    				
	        	    			}
	        	    			else {
	        	    				state++;
	        	    			}
        	    			}
        	    		//System.out.println("Retry "+retrycount+": cnt = "+cnt+", pixelsToTurn = "+pixelsToTurn+" closest = "+closest+" CENTERX="+CENTERX);
        				}
    					
    				}
    			}
    			else {
    				state = 0;
    				return true;
    			}
    			break;
    		case 6: // Done.  Do nothing for now.
    			state = 0;
    			return true;
    			
    	}
    	
    	return false;
    }
    
    double left_PID_I = 0, right_PID_I = 0;
    double targleft, targright;
    double lastleftEncoder, lastrightEncoder, leftEncoderdiff, rightEncoderdiff;
    int foundCount = 0;
    
    public boolean findTarget() {
    	// This routine will attempt to position encoders to match targleft and targright
    	// Using a fast and accurate PID-type control method.
    	double PFACTOR = 0.015;
    	double DFACTOR = 0.027; // was 0.065
    	double IFACTOR = 0.004; // was 0.0055
    	double IRANGE = 13; // Only apply I when we get pretty close to the target.
    	double MAXPOWER = 0.6;
    	double left_PID_P, right_PID_P, left_PID_D, right_PID_D;
    	double lefterr = targleft - leftEncoder.get();
    	double righterr = targright - rightEncoder.get();
    	leftEncoderdiff = leftEncoder.get() - lastleftEncoder;
    	rightEncoderdiff = rightEncoder.get() - lastrightEncoder;
    	
    	lastleftEncoder = leftEncoder.get();
    	lastrightEncoder = rightEncoder.get();
    	// Using get rate to see if this is useful for velocity.
    	// Data shows that the slow encoder update rate of the
    	// drive train can lead to rather poor rate values.  
    	// when speed is really 0, we sometimes get multiple 
    	// readings of a fairly high rate that should be 0.
    	// recommend tracking encoder readings and use a rate of 0
    	// if the encoder readings don't change in 1/50sec.
    	//double leftvel = leftEncoder.getRate();
    	//double rightvel = rightEncoder.getRate();
    	
    	left_PID_D = leftEncoderdiff * DFACTOR;
    	right_PID_D = rightEncoderdiff * DFACTOR;
    	
    	left_PID_P = lefterr * PFACTOR;
    	right_PID_P = righterr * PFACTOR;
    	
    	if (Math.abs(lefterr) < IRANGE) {
    		left_PID_I += lefterr * IFACTOR;
    	} else {
    		left_PID_I = 0;
    	}
    	
    	if (Math.abs(righterr) < IRANGE) {
    		right_PID_I += righterr * IFACTOR;
    	} else {
    		right_PID_I = 0;
    	}
    	
    	double leftpwr = left_PID_P - left_PID_D + left_PID_I;
    	double rightpwr = right_PID_P - right_PID_D + right_PID_I;

    	if (leftpwr > MAXPOWER)
   	   		leftpwr =  MAXPOWER;
   	   	if (leftpwr < -MAXPOWER)
   	   		leftpwr = -MAXPOWER;
   		if (rightpwr > MAXPOWER)
   			rightpwr = MAXPOWER;
   		if (rightpwr < -MAXPOWER)
   			rightpwr = -MAXPOWER;
    	
    	//System.out.println(cameraXPos + ", " + lefterr+","+righterr+","+leftpwr+","+rightpwr+","+leftEncoderdiff+","+rightEncoderdiff+","+left_PID_P+","+right_PID_P+","+left_PID_D+","+right_PID_D);
    	setLeftMotor(-leftpwr);
    	setRightMotor(-rightpwr);
    	if (Math.abs(lefterr) < 2.0 && Math.abs(righterr) < 2.0) {
    		foundCount++;
    	}
    	else {
    		foundCount = 0;
    	}
    	if (foundCount > 12) {
    		return true;
    	}
    	return false;
    }
    public void DrivePath(double leftPos, double leftSpeed, double rightPos, double rightSpeed) {
    	// This routine will attempt to put the drive train on the path defined by the speeds and positions.
    	double PFACTOR = 0.01; // Position Error Multiplier.  0.01 works fairly well.
    	// double DFACTOR = 0.0; // Probably won't use this.
    	double IFACTOR = 0.02; // Speed multiplier.  0.02 seems to work fairly well.
    	double MAXPOWER = 0.90;
    	double left_P, right_P, left_I, right_I;
    	double lefterr = leftPos - leftEncoder.get();
    	double righterr = rightPos - rightEncoder.get();
    	leftEncoderdiff = leftEncoder.get() - lastleftEncoder;
    	rightEncoderdiff = rightEncoder.get() - lastrightEncoder;
    	
    	lastleftEncoder = leftEncoder.get();
    	lastrightEncoder = rightEncoder.get();
    	
    	left_P = lefterr * PFACTOR;
    	right_P = righterr * PFACTOR;
    	
    	left_I = leftSpeed * IFACTOR;
    	right_I = rightSpeed * IFACTOR;
    	
    	double leftpwr = left_P + left_I;
    	double rightpwr = right_P + right_I;

    	if (leftpwr > MAXPOWER)
   	   		leftpwr =  MAXPOWER;
   	   	if (leftpwr < -MAXPOWER)
   	   		leftpwr = -MAXPOWER;
   		if (rightpwr > MAXPOWER)
   			rightpwr = MAXPOWER;
   		if (rightpwr < -MAXPOWER)
   			rightpwr = -MAXPOWER;
   		
   		System.out.printf("LP=%6.2f RP=%6.2f LS=%6.2f RS=%6.2f LPWR=%6.2f RPWR=%6.2f Lerr:%6.2f=%6.2f-%6.2f Rerr:%6.2f=%6.2f-%6.2f \n",leftPos,rightPos,leftSpeed,rightSpeed,leftpwr,rightpwr,lefterr,leftPos,lastleftEncoder,righterr,rightPos,lastrightEncoder);
    	setLeftMotor(-leftpwr);
    	setRightMotor(-rightpwr);
    	
    }
    
    double timecnt,totaltime;
    double fpgaDiff, lastFPGA;
    public boolean Cheval() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA; //acurate time tracker
		lastFPGA = Timer.getFPGATimestamp();

    	switch(chevalState) {
    	case 0:
    		goToDistance(-150, -150, 0.35, 5, 5, 0.3, 0.2);
    		if (getLeftSpeed() < 30 && count > 15) {
    			chevalState++;
    			count = 0;
    			resetGyro();
    		}
    		count++;
    		break;
    	case 1:
    		Robot.pickupArm.setArmMode("lowBar");
    		if (Robot.pickupArm.getElbowError() < 200) {
    			chevalState++;
    			timecnt = 0;
    			totaltime = 0.5;
    			resetEncoders();
    		}
    		break;
    	case 2: // Use DrivePath.  use +ve values for backwards, -ve values to go forward
    		timecnt += fpgaDiff;
    		DrivePath(-200*timecnt/totaltime,-10,-200*timecnt/totaltime,-10);
    		if (timecnt >= totaltime) {
    			chevalState++;
    			count = 0;	
    			resetEncoders();
    		}    		
    		break;
    	case 3://slight delay before switching directions
    		DrivePath(0,0,0,0); // Tell drive train to stop completely
    		if (count > 10) {
    			chevalState++;
    			count = 0;
    			timecnt = 0;
    			totaltime = 0.55;
    		}
    		count ++;
    		break;
    	case 4:
    		timecnt += fpgaDiff;
    		DrivePath(500*timecnt/totaltime,10,500*timecnt/totaltime,10);
    		if (timecnt >= totaltime) {
    			chevalState++;
    			count = 0;	
    			resetEncoders();
    		}    		
    		break;
    	case 5:
    		Robot.pickupArm.setArmMode("Hold");
			chevalState++;
			count = 0;
			timecnt = 0;
			totaltime = 1.1; // Prepare to drive the rest of the way over the Cheval
    		break;
    	case 6:
    		timecnt += fpgaDiff;
    		DrivePath(900*timecnt/totaltime,10,900*timecnt/totaltime,10);
    		if (timecnt >= totaltime) {
    			chevalState++;
    			count = 0;	
    			resetEncoders();
    		}
    		break;
    	case 7:
    		Robot.robotDrive.setRightMotor(0);
			Robot.robotDrive.setLeftMotor(0);
    		return true;
    		
    	}
    	return false;
    	
    }

}
